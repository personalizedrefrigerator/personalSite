/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./components/NoteEditor/ImageEditor/editor.css":
/*!********************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./components/NoteEditor/ImageEditor/editor.css ***!
  \********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\ncanvas {\\n\\tposition: fixed;\\n\\tleft: 0;\\n\\tright: 0;\\n\\ttop: 0;\\n\\tbottom: 0;\\n\\twidth: 100vw;\\n\\theight: 100vh;\\n\\ttouch-action: none;\\n}\\n\\n.loadingMessage {\\n\\tposition: fixed;\\n\\ttext-align: center;\\n\\tfont-family: system-ui, -apple-system, sans-serif;\\n\\tfont-size: 2em;\\n\\n\\tbottom: 0;\\n\\tleft: 0;\\n\\tright: 0;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/editor.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./components/NoteEditor/ImageEditor/toolbar/toolbar.css":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./components/NoteEditor/ImageEditor/toolbar/toolbar.css ***!
  \*****************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n:root {\\n    --primary-background-color: white;\\n    --primary-background-color-transparent: rgba(255, 255, 255, 0.5);\\n    --secondary-background-color: #faf;\\n    --primary-foreground-color: black;\\n    --secondary-foreground-color: black;\\n}\\n\\n.toolbar-root {\\n    background-color: var(--primary-background-color-transparent);\\n    backdrop-filter: blur(6px);\\n\\n    border: 1px solid gray;\\n    border-radius: 2px;\\n    flex-wrap: wrap;\\n\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n\\n    font-family: system-ui, -apple-system, sans-serif;\\n}\\n\\n.toolbar-button {\\n    display: flex;\\n    flex-direction: column;\\n    align-items: center;\\n    text-align: center;\\n    border-radius: 2px;\\n    transition: background-color 0.25s ease;\\n    cursor: pointer;\\n\\n    padding-left: 3px;\\n    padding-right: 3px;\\n\\n    min-width: 40px;\\n    max-width: 70px;\\n    font-size: 11pt;\\n\\n    height: min(20vh, 60px);\\n    background-color: white;\\n}\\n\\n.toolbar-button .toolbar-icon {\\n    flex-shrink: 1;\\n    min-width: 30px;\\n}\\n\\n.toolbar-toolContainer.selected .toolbar-button {\\n    background-color: var(--secondary-background-color);\\n    color: var(--secondary-foreground-color);\\n}\\n\\n.toolbar-toolContainer:not(.selected) .toolbar-showHideDropdownIcon {\\n    display: none;\\n}\\n\\n.toolbar-toolContainer.selected .toolbar-showHideDropdownIcon {\\n    height: 10px;\\n    transition: transform 0.5s ease;\\n}\\n\\n.toolbar-toolContainer.dropdownVisible .toolbar-showHideDropdownIcon {\\n    transform: rotate(180deg);\\n}\\n\\n.toolbar-dropdown.hidden, .toolbar-toolContainer:not(.selected) > .toolbar-dropdown {\\n    display: none;\\n}\\n\\n.toolbar-dropdown {\\n    position: absolute;\\n    padding: 15px;\\n    background-color: var(--primary-background-color);\\n    box-shadow: 0px 3px 3px var(--primary-foreground-color);\\n}\\n\\n/* Color selector inputs */\\n.toolbar-dropdown .clr-field button {\\n    width: 100%;\\n    height: 100%;\\n    border-radius: 2px;\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/toolbar/toolbar.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/@melloware/coloris/dist/coloris.css":
/*!************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/@melloware/coloris/dist/coloris.css ***!
  \************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".clr-picker {\\r\\n  display: none;\\r\\n  flex-wrap: wrap;\\r\\n  position: absolute;\\r\\n  width: 200px;\\r\\n  z-index: 1000;\\r\\n  border-radius: 10px;\\r\\n  background-color: #fff;\\r\\n  justify-content: space-between;\\r\\n  box-shadow: 0 0 5px rgba(0,0,0,.05), 0 5px 20px rgba(0,0,0,.1);\\r\\n  -moz-user-select: none;\\r\\n  -webkit-user-select: none;\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-open,\\r\\n.clr-picker[data-inline=\\\"true\\\"] {\\r\\n  display: flex;\\r\\n}\\r\\n\\r\\n.clr-picker[data-inline=\\\"true\\\"] {\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n.clr-gradient {\\r\\n  position: relative;\\r\\n  width: 100%;\\r\\n  height: 100px;\\r\\n  margin-bottom: 15px;\\r\\n  border-radius: 3px 3px 0 0;\\r\\n  background-image: linear-gradient(rgba(0,0,0,0), #000), linear-gradient(90deg, #fff, currentColor);\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-marker {\\r\\n  position: absolute;\\r\\n  width: 12px;\\r\\n  height: 12px;\\r\\n  margin: -6px 0 0 -6px;\\r\\n  border: 1px solid #fff;\\r\\n  border-radius: 50%;\\r\\n  background-color: currentColor;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-webkit-slider-runnable-track {\\r\\n  width: 100%;\\r\\n  height: 8px;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-webkit-slider-thumb {\\r\\n  width: 8px;\\r\\n  height: 8px;\\r\\n  -webkit-appearance: none;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-moz-range-track {\\r\\n  width: 100%;\\r\\n  height: 8px;\\r\\n  border: 0;\\r\\n}\\r\\n\\r\\n.clr-picker input[type=\\\"range\\\"]::-moz-range-thumb {\\r\\n  width: 8px;\\r\\n  height: 8px;\\r\\n  border: 0;\\r\\n}\\r\\n\\r\\n.clr-hue {\\r\\n  background-image: linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%);\\r\\n}\\r\\n\\r\\n.clr-hue,\\r\\n.clr-alpha {\\r\\n  position: relative;\\r\\n  width: calc(100% - 40px);\\r\\n  height: 8px;\\r\\n  margin: 5px 20px;\\r\\n  border-radius: 4px;\\r\\n}\\r\\n\\r\\n.clr-alpha span {\\r\\n  display: block;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  border-radius: inherit;\\r\\n  background-image: linear-gradient(90deg, rgba(0,0,0,0), currentColor);\\r\\n}\\r\\n\\r\\n.clr-hue input,\\r\\n.clr-alpha input {\\r\\n  position: absolute;\\r\\n  width: calc(100% + 16px);\\r\\n  height: 16px;\\r\\n  left: -8px;\\r\\n  top: -4px;\\r\\n  margin: 0;\\r\\n  background-color: transparent;\\r\\n  opacity: 0;\\r\\n  cursor: pointer;\\r\\n  appearance: none;\\r\\n  -webkit-appearance: none;\\r\\n}\\r\\n\\r\\n.clr-hue div,\\r\\n.clr-alpha div {\\r\\n  position: absolute;\\r\\n  width: 16px;\\r\\n  height: 16px;\\r\\n  left: 0;\\r\\n  top: 50%;\\r\\n  margin-left: -8px;\\r\\n  transform: translateY(-50%);\\r\\n  border: 2px solid #fff;\\r\\n  border-radius: 50%;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: 0 0 1px #888;\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-alpha div:before {\\r\\n  content: '';\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border-radius: 50%;\\r\\n  background-color: currentColor;\\r\\n}\\r\\n\\r\\n.clr-format {\\r\\n  display: none;\\r\\n  order: 1;\\r\\n  width: calc(100% - 40px);\\r\\n  margin: 0 20px 20px;\\r\\n}\\r\\n\\r\\n.clr-segmented {\\r\\n  display: flex;\\r\\n  position: relative;\\r\\n  width: 100%;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  border: 1px solid #ddd;\\r\\n  border-radius: 15px;\\r\\n  box-sizing: border-box;\\r\\n  color: #999;\\r\\n  font-size: 12px;\\r\\n}\\r\\n\\r\\n.clr-segmented input,\\r\\n.clr-segmented legend {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  border: 0;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  opacity: 0;\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-segmented label {\\r\\n  flex-grow: 1;\\r\\n  padding: 4px 0;\\r\\n  text-align: center;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-segmented label:first-of-type {\\r\\n  border-radius: 10px 0 0 10px;\\r\\n}\\r\\n\\r\\n.clr-segmented label:last-of-type {\\r\\n  border-radius: 0 10px 10px 0;\\r\\n}\\r\\n\\r\\n.clr-segmented input:checked + label {\\r\\n  color: #fff;\\r\\n  background-color: #666;\\r\\n}\\r\\n\\r\\n.clr-swatches {\\r\\n  order: 2;\\r\\n  width: calc(100% - 32px);\\r\\n  margin: 0 16px;\\r\\n}\\r\\n\\r\\n.clr-swatches div {\\r\\n  display: flex;\\r\\n  flex-wrap: wrap;\\r\\n  padding-bottom: 12px;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.clr-swatches button {\\r\\n  position: relative;\\r\\n  width: 20px;\\r\\n  height: 20px;\\r\\n  margin: 0 4px 6px 4px;\\r\\n  border: 0;\\r\\n  border-radius: 50%;\\r\\n  color: inherit;\\r\\n  text-indent: -1000px;\\r\\n  white-space: nowrap;\\r\\n  overflow: hidden;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-swatches button:after {\\r\\n  content: '';\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border-radius: inherit;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);\\r\\n}\\r\\n\\r\\ninput.clr-color {\\r\\n  order: 1;\\r\\n  width: calc(100% - 80px);\\r\\n  height: 32px;\\r\\n  margin: 15px 20px 20px 0;\\r\\n  padding: 0 10px;\\r\\n  border: 1px solid #ddd;\\r\\n  border-radius: 16px;\\r\\n  color: #444;\\r\\n  background-color: #fff;\\r\\n  font-family: sans-serif;\\r\\n  font-size: 14px;\\r\\n  text-align: center;\\r\\n  box-shadow: none;\\r\\n}\\r\\n\\r\\ninput.clr-color:focus {\\r\\n  outline: none;\\r\\n  border: 1px solid #1e90ff;\\r\\n}\\r\\n\\r\\n.clr-clear {\\r\\n  display: none;\\r\\n  order: 2;\\r\\n  height: 24px;\\r\\n  margin: 0 20px 20px auto;\\r\\n  padding: 0 20px;\\r\\n  border: 0;\\r\\n  border-radius: 12px;\\r\\n  color: #fff;\\r\\n  background-color: #666;\\r\\n  font-family: inherit;\\r\\n  font-size: 12px;\\r\\n  font-weight: 400;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-preview {\\r\\n  position: relative;\\r\\n  width: 32px;\\r\\n  height: 32px;\\r\\n  margin: 15px 0 20px 20px;\\r\\n  border: 0;\\r\\n  border-radius: 50%;\\r\\n  overflow: hidden;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.clr-preview:before,\\r\\n.clr-preview:after {\\r\\n  content: '';\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border: 1px solid #fff;\\r\\n  border-radius: 50%;\\r\\n}\\r\\n\\r\\n.clr-preview:after {\\r\\n  border: 0;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);\\r\\n}\\r\\n\\r\\n.clr-marker,\\r\\n.clr-hue div,\\r\\n.clr-alpha div,\\r\\n.clr-color {\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.clr-field {\\r\\n  display: inline-block;\\r\\n  position: relative;\\r\\n  color: transparent;\\r\\n}\\r\\n\\r\\n.clr-field button {\\r\\n  position: absolute;\\r\\n  width: 30px;\\r\\n  height: 100%;\\r\\n  right: 0;\\r\\n  top: 50%;\\r\\n  transform: translateY(-50%);\\r\\n  border: 0;\\r\\n  color: inherit;\\r\\n  text-indent: -1000px;\\r\\n  white-space: nowrap;\\r\\n  overflow: hidden;\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-field button:after {\\r\\n  content: '';\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  left: 0;\\r\\n  top: 0;\\r\\n  border-radius: inherit;\\r\\n  background-color: currentColor;\\r\\n  box-shadow: inset 0 0 1px rgba(0,0,0,.5);\\r\\n}\\r\\n\\r\\n.clr-alpha,\\r\\n.clr-alpha div,\\r\\n.clr-swatches button,\\r\\n.clr-preview:before,\\r\\n.clr-field button {\\r\\n  background-image: repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa), repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);\\r\\n  background-position: 0 0, 4px 4px;\\r\\n  background-size: 8px 8px;\\r\\n}\\r\\n\\r\\n.clr-marker:focus {\\r\\n  outline: none;\\r\\n}\\r\\n\\r\\n.clr-keyboard-nav .clr-marker:focus,\\r\\n.clr-keyboard-nav .clr-hue input:focus + div,\\r\\n.clr-keyboard-nav .clr-alpha input:focus + div,\\r\\n.clr-keyboard-nav .clr-segmented input:focus + label {\\r\\n  outline: none;\\r\\n  box-shadow: 0 0 0 2px #1e90ff, 0 0 2px 2px #fff;\\r\\n}\\r\\n\\r\\n.clr-picker[data-alpha=\\\"false\\\"] .clr-alpha {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.clr-picker[data-minimal=\\\"true\\\"] {\\r\\n  padding-top: 16px;\\r\\n}\\r\\n\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-gradient,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-hue,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-alpha,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-color,\\r\\n.clr-picker[data-minimal=\\\"true\\\"] .clr-preview {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n/** Dark theme **/\\r\\n\\r\\n.clr-dark {\\r\\n  background-color: #444;\\r\\n}\\r\\n\\r\\n.clr-dark .clr-segmented {\\r\\n  border-color: #777;\\r\\n}\\r\\n\\r\\n.clr-dark .clr-swatches button:after {\\r\\n  box-shadow: inset 0 0 0 1px rgba(255,255,255,.3);\\r\\n}\\r\\n\\r\\n.clr-dark input.clr-color {\\r\\n  color: #fff;\\r\\n  border-color: #777;\\r\\n  background-color: #555;\\r\\n}\\r\\n\\r\\n.clr-dark input.clr-color:focus {\\r\\n  border-color: #1e90ff;\\r\\n}\\r\\n\\r\\n.clr-dark .clr-preview:after {\\r\\n  box-shadow: inset 0 0 0 1px rgba(255,255,255,.5);\\r\\n}\\r\\n\\r\\n.clr-dark .clr-alpha,\\r\\n.clr-dark .clr-alpha div,\\r\\n.clr-dark .clr-swatches button,\\r\\n.clr-dark .clr-preview:before {\\r\\n  background-image: repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888), repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888);\\r\\n}\\r\\n\\r\\n/** Polaroid theme **/\\r\\n\\r\\n.clr-picker.clr-polaroid {\\r\\n  border-radius: 6px;\\r\\n  box-shadow: 0 0 5px rgba(0,0,0,.1), 0 5px 30px rgba(0,0,0,.2);\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid:before {\\r\\n  content: '';\\r\\n  display: block;\\r\\n  position: absolute;\\r\\n  width: 16px;\\r\\n  height: 10px;\\r\\n  left: 20px;\\r\\n  top: -10px;\\r\\n  border: solid transparent;\\r\\n  border-width: 0 8px 10px 8px;\\r\\n  border-bottom-color: currentColor;\\r\\n  box-sizing: border-box;\\r\\n  color: #fff;\\r\\n  filter: drop-shadow(0 -4px 3px rgba(0,0,0,.1));\\r\\n  pointer-events: none;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid.clr-dark:before {\\r\\n  color: #444;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid.clr-left:before {\\r\\n  left: auto;\\r\\n  right: 20px;\\r\\n}\\r\\n\\r\\n.clr-picker.clr-polaroid.clr-top:before {\\r\\n  top: auto;\\r\\n  bottom: -10px;\\r\\n  transform: rotateZ(180deg);\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-gradient {\\r\\n  width: calc(100% - 20px);\\r\\n  height: 120px;\\r\\n  margin: 10px;\\r\\n  border-radius: 3px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-hue,\\r\\n.clr-polaroid .clr-alpha {\\r\\n  width: calc(100% - 30px);\\r\\n  height: 10px;\\r\\n  margin: 6px 15px;\\r\\n  border-radius: 5px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-hue div,\\r\\n.clr-polaroid .clr-alpha div {\\r\\n  box-shadow: 0 0 5px rgba(0,0,0,.2);\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-format {\\r\\n  width: calc(100% - 20px);\\r\\n  margin: 0 10px 15px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-swatches {\\r\\n  width: calc(100% - 12px);\\r\\n  margin: 0 6px;\\r\\n}\\r\\n.clr-polaroid .clr-swatches div {\\r\\n  padding-bottom: 10px;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-swatches button {\\r\\n  width: 22px;\\r\\n  height: 22px;\\r\\n}\\r\\n\\r\\n.clr-polaroid input.clr-color {\\r\\n  width: calc(100% - 60px);\\r\\n  margin: 10px 10px 15px 0;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-clear {\\r\\n  margin: 0 10px 15px auto;\\r\\n}\\r\\n\\r\\n.clr-polaroid .clr-preview {\\r\\n  margin: 10px 0 15px 10px;\\r\\n}\\r\\n\\r\\n/** Large theme **/\\r\\n\\r\\n.clr-picker.clr-large {\\r\\n  width: 275px;\\r\\n}\\r\\n\\r\\n.clr-large .clr-gradient {\\r\\n  height: 150px;\\r\\n}\\r\\n\\r\\n.clr-large .clr-swatches button {\\r\\n  width: 22px;\\r\\n  height: 22px;\\r\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://svgEditor/./node_modules/@melloware/coloris/dist/coloris.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://svgEditor/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://svgEditor/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/editor.css":
/*!******************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/editor.css ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_editor_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!./editor.css */ \"./node_modules/css-loader/dist/cjs.js!./components/NoteEditor/ImageEditor/editor.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_editor_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/editor.css?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/toolbar/toolbar.css":
/*!***************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/toolbar/toolbar.css ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_toolbar_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../node_modules/css-loader/dist/cjs.js!./toolbar.css */ \"./node_modules/css-loader/dist/cjs.js!./components/NoteEditor/ImageEditor/toolbar/toolbar.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_toolbar_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_toolbar_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_toolbar_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_toolbar_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/toolbar/toolbar.css?");

/***/ }),

/***/ "./node_modules/@melloware/coloris/dist/coloris.css":
/*!**********************************************************!*\
  !*** ./node_modules/@melloware/coloris/dist/coloris.css ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./coloris.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/@melloware/coloris/dist/coloris.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _css_loader_dist_cjs_js_coloris_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://svgEditor/./node_modules/@melloware/coloris/dist/coloris.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://svgEditor/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://svgEditor/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://svgEditor/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://svgEditor/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://svgEditor/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://svgEditor/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/Color4.ts":
/*!*****************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/Color4.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Color4 {\n    constructor(r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.hexString = null;\n    }\n    /**\n     * @param red The red component of the color, in the range [0, 1]\n     * @param green The green component, in [0, 1] where 1 is most green\n     * @param blue The blue component\n     * @return A Color4 with the given red, green, blue values and an alpha channel of 1.\n     */\n    static ofRGB(red, green, blue) {\n        return new Color4(red, green, blue, 1.0);\n    }\n    static ofRGBA(red, green, blue, alpha) {\n        return new Color4(red, green, blue, alpha);\n    }\n    static fromHex(hexString) {\n        // Remove starting '#' (if present)\n        hexString = hexString.match(/^[#]?(.*)$/)[1];\n        hexString = hexString.toUpperCase();\n        if (!hexString.match(/^[0-9A-F]+$/)) {\n            throw new Error(`${hexString} is not in a valid format.`);\n        }\n        // RGBA or RGB\n        if (hexString.length === 3 || hexString.length === 4) {\n            // Each character is a component\n            const components = hexString.split('');\n            // Convert to RRGGBBAA or RRGGBB format\n            hexString = components.map(component => `${component}0`).join('');\n        }\n        if (hexString.length === 6) {\n            // Alpha component\n            hexString += 'FF';\n        }\n        const components = [];\n        for (let i = 2; i <= hexString.length; i += 2) {\n            const chunk = hexString.substring(i - 2, i);\n            components.push(parseInt(chunk, 16) / 255);\n        }\n        if (components.length !== 4) {\n            throw new Error(`Unable to parse ${hexString}: Wrong number of components.`);\n        }\n        return new Color4(components[0], components[1], components[2], components[3]);\n    }\n    static fromString(text) {\n        const colorNameMap = {\n            white: '#fff',\n            black: '#000',\n            blue: '#00f',\n            red: '#f00',\n        };\n        if (text in colorNameMap) {\n            text = colorNameMap[text];\n        }\n        if (text.startsWith('#')) {\n            return Color4.fromHex(text);\n        }\n        else {\n            // Otherwise, try to use an HTML5Canvas to determine the color\n            const canvas = document.createElement('canvas');\n            canvas.width = 1;\n            canvas.height = 1;\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = text;\n            ctx.fillRect(0, 0, 1, 1);\n            const data = ctx.getImageData(0, 0, 1, 1);\n            const red = data.data[0] / 255;\n            const green = data.data[1] / 255;\n            const blue = data.data[2] / 255;\n            const alpha = data.data[3] / 255;\n            return Color4.ofRGBA(red, green, blue, alpha);\n        }\n    }\n    eq(other) {\n        if ((other !== null && other !== void 0 ? other : null) === null) {\n            return false;\n        }\n        return this.toHexString() === other.toHexString();\n    }\n    toHexString() {\n        if (this.hexString) {\n            return this.hexString;\n        }\n        const componentToHex = (component) => {\n            const res = Math.round(255 * component).toString(16);\n            if (res.length === 1) {\n                return `0${res}`;\n            }\n            return res;\n        };\n        const alpha = componentToHex(this.a);\n        const red = componentToHex(this.r);\n        const green = componentToHex(this.g);\n        const blue = componentToHex(this.b);\n        if (alpha === 'ff') {\n            return `#${red}${green}${blue}`;\n        }\n        this.hexString = `#${red}${green}${blue}${alpha}`;\n        return this.hexString;\n    }\n}\nexports[\"default\"] = Color4;\nColor4.transparent = Color4.ofRGBA(0, 0, 0, 0);\nColor4.red = Color4.ofRGB(1.0, 0.0, 0.0);\nColor4.green = Color4.ofRGB(0.0, 1.0, 0.0);\nColor4.blue = Color4.ofRGB(0.0, 0.0, 1.0);\nColor4.purple = Color4.ofRGB(0.5, 0.2, 0.5);\nColor4.yellow = Color4.ofRGB(1, 1, 0.1);\nColor4.clay = Color4.ofRGB(0.8, 0.4, 0.2);\nColor4.black = Color4.ofRGB(0, 0, 0);\nColor4.white = Color4.ofRGB(1, 1, 1);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/Color4.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/Display.ts":
/*!******************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/Display.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderingMode = void 0;\nconst CanvasRenderer_1 = __webpack_require__(/*! ./rendering/CanvasRenderer */ \"./components/NoteEditor/ImageEditor/rendering/CanvasRenderer.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nconst DummyRenderer_1 = __webpack_require__(/*! ./rendering/DummyRenderer */ \"./components/NoteEditor/ImageEditor/rendering/DummyRenderer.ts\");\nvar RenderingMode;\n(function (RenderingMode) {\n    RenderingMode[RenderingMode[\"DummyRenderer\"] = 0] = \"DummyRenderer\";\n    RenderingMode[RenderingMode[\"CanvasRenderer\"] = 1] = \"CanvasRenderer\";\n})(RenderingMode = exports.RenderingMode || (exports.RenderingMode = {}));\nclass Display {\n    constructor(editor, mode, parent) {\n        this.editor = editor;\n        this.parent = parent;\n        if (mode === RenderingMode.CanvasRenderer) {\n            this.initializeCanvasRendering();\n        }\n        else {\n            this.dryInkRenderer = new DummyRenderer_1.default(editor.viewport);\n            this.wetInkRenderer = new DummyRenderer_1.default(editor.viewport);\n        }\n        // TODO: SVG case\n        this.editor.notifier.on(types_1.EditorEventType.DisplayResized, event => {\n            var _a;\n            if (event.kind !== types_1.EditorEventType.DisplayResized) {\n                throw new Error('Mismatched event.kinds!');\n            }\n            (_a = this.resizeSurfacesCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n    // Returns the visible width of the display (e.g. how much\n    // space the display's element takes up in the x direction\n    // in the DOM).\n    get width() {\n        return this.dryInkRenderer.displaySize().x;\n    }\n    get height() {\n        return this.dryInkRenderer.displaySize().y;\n    }\n    initializeCanvasRendering() {\n        const dryInkCanvas = document.createElement('canvas');\n        const wetInkCanvas = document.createElement('canvas');\n        const dryInkCtx = dryInkCanvas.getContext('2d');\n        const wetInkCtx = wetInkCanvas.getContext('2d');\n        this.dryInkRenderer = new CanvasRenderer_1.default(dryInkCtx, this.editor.viewport);\n        this.wetInkRenderer = new CanvasRenderer_1.default(wetInkCtx, this.editor.viewport);\n        dryInkCanvas.className = 'dryInkCanvas';\n        wetInkCanvas.className = 'wetInkCanvas';\n        if (this.parent) {\n            this.parent.appendChild(dryInkCanvas);\n            this.parent.appendChild(wetInkCanvas);\n        }\n        this.resizeSurfacesCallback = () => {\n            const hasSizeMismatch = (canvas) => {\n                return canvas.clientHeight !== canvas.height || canvas.clientWidth !== canvas.width;\n            };\n            // Ensure that the drawing surfaces sizes match the\n            // canvas' sizes to prevent stretching.\n            if (hasSizeMismatch(dryInkCanvas) || hasSizeMismatch(wetInkCanvas)) {\n                dryInkCanvas.width = dryInkCanvas.clientWidth;\n                dryInkCanvas.height = dryInkCanvas.clientHeight;\n                wetInkCanvas.width = wetInkCanvas.clientWidth;\n                wetInkCanvas.height = wetInkCanvas.clientHeight;\n            }\n        };\n        this.resizeSurfacesCallback();\n        this.flattenCallback = () => {\n            dryInkCtx.drawImage(wetInkCanvas, 0, 0);\n        };\n    }\n    // Clears the drawing surfaces and otherwise prepares for a rerender.\n    startRerender() {\n        var _a;\n        (_a = this.resizeSurfacesCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.wetInkRenderer.clear();\n        this.dryInkRenderer.clear();\n        return this.dryInkRenderer;\n    }\n    getDryInkRenderer() {\n        return this.dryInkRenderer;\n    }\n    getWetInkRenderer() {\n        return this.wetInkRenderer;\n    }\n    // Re-renders the contents of the wetInkRenderer onto the dryInkRenderer\n    flatten() {\n        var _a;\n        (_a = this.flattenCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\nexports[\"default\"] = Display;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/Display.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/EditorImage.ts":
/*!**********************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/EditorImage.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageNode = void 0;\nconst Rect2_1 = __webpack_require__(/*! ./geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\n/**\n * A tree of nodes contained within the editor\n */\nclass EditorImage {\n    constructor() {\n        this.id = Math.random();\n        this.root = new ImageNode();\n    }\n    addElement(elem) {\n        return this.root.addLeaf(elem);\n    }\n    // Returns the parent of the given element, if it exists.\n    findParent(elem) {\n        const candidates = this.root.getLeavesInRegion(elem.getBBox());\n        for (const candidate of candidates) {\n            if (candidate.getContent() === elem) {\n                return candidate;\n            }\n        }\n        return null;\n    }\n    sortLeaves(leaves) {\n        leaves.sort((a, b) => a.getContent().zIndex - b.getContent().zIndex);\n    }\n    render(renderer, viewport, minFraction = 0.001) {\n        // Don't render components that are < 0.1% of the viewport.\n        const leaves = this.root.getLeavesInRegion(viewport.visibleRect, minFraction);\n        this.sortLeaves(leaves);\n        for (const leaf of leaves) {\n            leaf.getContent().render(renderer, viewport.visibleRect);\n        }\n    }\n    // Renders all nodes, even ones not within the viewport\n    renderAll(renderer) {\n        const leaves = this.root.getLeaves();\n        this.sortLeaves(leaves);\n        for (const leaf of leaves) {\n            leaf.getContent().render(renderer, leaf.getBBox());\n        }\n    }\n    getElementsIntersectingRegion(region) {\n        const leaves = this.root.getLeavesInRegion(region);\n        this.sortLeaves(leaves);\n        return leaves.map(leaf => leaf.getContent());\n    }\n}\nexports[\"default\"] = EditorImage;\nEditorImage.AddElementCommand = class {\n    // If [applyByFlattening], then the rendered content of this element\n    // is present on the display's wet ink canvas. As such, no re-render is necessary\n    // the first time this command is applied (the surfaces are joined instead).\n    constructor(element, applyByFlattening = false) {\n        this.element = element;\n        this.applyByFlattening = applyByFlattening;\n    }\n    apply(editor) {\n        this.elementContainer = editor.image.addElement(this.element);\n        if (!this.applyByFlattening) {\n            editor.queueRerender();\n        }\n        else {\n            this.applyByFlattening = false;\n            editor.display.flatten();\n        }\n    }\n    unapply(editor) {\n        var _a;\n        (_a = this.elementContainer) === null || _a === void 0 ? void 0 : _a.remove();\n        this.elementContainer = null;\n        editor.queueRerender();\n    }\n};\nclass ImageNode {\n    constructor(parent = null) {\n        this.parent = parent;\n        this.targetChildCount = 30;\n        this.children = [];\n        this.bbox = Rect2_1.default.empty;\n        this.content = null;\n    }\n    getContent() {\n        return this.content;\n    }\n    getParent() {\n        return this.parent;\n    }\n    getChildrenInRegion(region) {\n        return this.children.filter(child => {\n            return child.getBBox().intersects(region);\n        });\n    }\n    /** @returns a list of `ImageNode`s with content (and thus no children). */\n    getLeavesInRegion(region, minFractionOfRegion = 0) {\n        const result = [];\n        // Don't render if too small\n        if (this.bbox.maxDimension / region.maxDimension <= minFractionOfRegion) {\n            return [];\n        }\n        if (this.content !== null && this.getBBox().intersects(region)) {\n            result.push(this);\n        }\n        const children = this.getChildrenInRegion(region);\n        for (const child of children) {\n            result.push(...child.getLeavesInRegion(region, minFractionOfRegion));\n        }\n        return result;\n    }\n    // Returns a list of leaves with this as an ancestor.\n    // Like getLeavesInRegion, but does not check whether ancestors are in a given rectangle\n    getLeaves() {\n        if (this.content) {\n            return [this];\n        }\n        const result = [];\n        for (const child of this.children) {\n            result.push(...child.getLeaves());\n        }\n        return result;\n    }\n    addLeaf(leaf) {\n        if (this.content === null && this.children.length === 0) {\n            this.content = leaf;\n            this.recomputeBBox(true);\n            return this;\n        }\n        if (this.content !== null) {\n            console.assert(this.children.length === 0);\n            const contentNode = new ImageNode(this);\n            contentNode.content = this.content;\n            this.content = null;\n            this.children.push(contentNode);\n            contentNode.recomputeBBox(false);\n        }\n        // If this node is contained within the leaf, make this and the leaf\n        // share a parent.\n        const leafBBox = leaf.getBBox();\n        if (leafBBox.containsRect(this.getBBox())) {\n            // Create a node for this' children and for the new content..\n            const nodeForNewLeaf = new ImageNode(this);\n            const nodeForChildren = new ImageNode(this);\n            nodeForChildren.children = this.children;\n            this.children = [nodeForNewLeaf, nodeForChildren];\n            nodeForChildren.recomputeBBox(true);\n            return nodeForNewLeaf.addLeaf(leaf);\n        }\n        const containingNodes = this.children.filter(child => child.getBBox().containsRect(leafBBox));\n        // Does the leaf already fit within one of the children?\n        if (containingNodes.length > 0 && this.children.length >= this.targetChildCount) {\n            // Sort the containers in ascending order by area\n            containingNodes.sort((a, b) => a.getBBox().area - b.getBBox().area);\n            // Choose the smallest child that contains the new element.\n            const result = containingNodes[0].addLeaf(leaf);\n            result.rebalance();\n            return result;\n        }\n        const newNode = new ImageNode(this);\n        this.children.push(newNode);\n        newNode.content = leaf;\n        newNode.recomputeBBox(true);\n        return newNode;\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    // Recomputes this' bounding box. If [bubbleUp], also recompute\n    // this' ancestors bounding boxes\n    recomputeBBox(bubbleUp) {\n        var _a;\n        const oldBBox = this.bbox;\n        if (this.content != null) {\n            this.bbox = this.content.getBBox();\n        }\n        else {\n            this.bbox = Rect2_1.default.empty;\n            for (const child of this.children) {\n                this.bbox = this.bbox.union(child.getBBox());\n            }\n        }\n        if (bubbleUp && !oldBBox.eq(this.bbox)) {\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.recomputeBBox(true);\n        }\n    }\n    rebalance() {\n        // If the current node is its parent's only child,\n        if (this.parent && this.parent.children.length === 1) {\n            console.assert(this.parent.content === null);\n            console.assert(this.parent.children[0] === this);\n            // Remove this' parent, if this' parent isn't the root.\n            if (this.parent.parent !== null) {\n                const oldParent = this.parent;\n                oldParent.children = [];\n                this.parent = oldParent.parent;\n                this.parent.children.push(this);\n                oldParent.parent = null;\n                this.parent.recomputeBBox(false);\n            }\n            else if (this.content === null) {\n                // Remove this and transfer this' children to the parent.\n                this.parent.children = this.children;\n                this.parent = null;\n            }\n        }\n    }\n    /** Remove this node and all of its children */\n    remove() {\n        if (!this.parent) {\n            this.content = null;\n            this.children = [];\n            return;\n        }\n        const oldChildCount = this.parent.children.length;\n        this.parent.children = this.parent.children.filter(node => {\n            return node !== this;\n        });\n        console.assert(this.parent.children.length === oldChildCount - 1);\n        this.parent.children.forEach(child => {\n            child.rebalance();\n        });\n        this.parent.recomputeBBox(true);\n        // Invalidate/disconnect this.\n        this.content = null;\n        this.parent = null;\n        this.children = null;\n    }\n}\nexports.ImageNode = ImageNode;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/EditorImage.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/Pointer.ts":
/*!******************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/Pointer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PointerDevice = void 0;\nconst Vec2_1 = __webpack_require__(/*! ./geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nvar PointerDevice;\n(function (PointerDevice) {\n    PointerDevice[PointerDevice[\"Pen\"] = 0] = \"Pen\";\n    PointerDevice[PointerDevice[\"Touch\"] = 1] = \"Touch\";\n    PointerDevice[PointerDevice[\"Mouse\"] = 2] = \"Mouse\";\n    PointerDevice[PointerDevice[\"Other\"] = 3] = \"Other\";\n})(PointerDevice = exports.PointerDevice || (exports.PointerDevice = {}));\n// Provides a snapshot containing information about a pointer. A Pointer\n// object is immutable --- it will not be updated when the pointer's information changes.\nclass Pointer {\n    constructor(\n    // The (x, y) position of the pointer relative to the top-left corner\n    // of the visible canvas.\n    screenPos, \n    // Position of the pointer relative to the top left corner of the drawing\n    // surface.\n    canvasPos, pressure, isPrimary, down, device, \n    // Unique ID for the pointer\n    id, \n    // Numeric timestamp (milliseconds, as from (new Date).getTime())\n    timeStamp) {\n        this.screenPos = screenPos;\n        this.canvasPos = canvasPos;\n        this.pressure = pressure;\n        this.isPrimary = isPrimary;\n        this.down = down;\n        this.device = device;\n        this.id = id;\n        this.timeStamp = timeStamp;\n    }\n    static ofEvent(evt, isDown, viewport) {\n        var _a, _b;\n        const screenPos = Vec2_1.Vec2.of(evt.clientX, evt.clientY);\n        const pointerTypeToDevice = {\n            'mouse': PointerDevice.Mouse,\n            'pen': PointerDevice.Pen,\n            'touch': PointerDevice.Touch,\n        };\n        const device = (_a = pointerTypeToDevice[evt.pointerType]) !== null && _a !== void 0 ? _a : PointerDevice.Other;\n        const timeStamp = (new Date()).getTime();\n        const canvasPos = viewport.screenToCanvas(screenPos);\n        return new Pointer(screenPos, canvasPos, (_b = evt.pressure) !== null && _b !== void 0 ? _b : null, evt.isPrimary, isDown, device, evt.pointerId, timeStamp);\n    }\n    // Create a new Pointer from a point on the canvas.\n    // Intended for unit tests.\n    static ofCanvasPoint(canvasPos, isDown, viewport, id = 0, device = PointerDevice.Pen, isPrimary = true, pressure = null) {\n        const screenPos = viewport.canvasToScreen(canvasPos);\n        const timeStamp = (new Date()).getTime();\n        return new Pointer(screenPos, canvasPos, pressure, isPrimary, isDown, device, id, timeStamp);\n    }\n}\nexports[\"default\"] = Pointer;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/Pointer.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/SVGLoader.ts":
/*!********************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/SVGLoader.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultSVGViewRect = void 0;\nconst Color4_1 = __webpack_require__(/*! ./Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nconst Stroke_1 = __webpack_require__(/*! ./components/Stroke */ \"./components/NoteEditor/ImageEditor/components/Stroke.ts\");\nconst UnknownSVGObject_1 = __webpack_require__(/*! ./components/UnknownSVGObject */ \"./components/NoteEditor/ImageEditor/components/UnknownSVGObject.ts\");\nconst Path_1 = __webpack_require__(/*! ./geometry/Path */ \"./components/NoteEditor/ImageEditor/geometry/Path.ts\");\nconst Rect2_1 = __webpack_require__(/*! ./geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\n// Size of a loaded image if no size is specified.\nexports.defaultSVGViewRect = new Rect2_1.default(0, 0, 500, 500);\nclass SVGLoader {\n    constructor(source, onFinish) {\n        this.source = source;\n        this.onFinish = onFinish;\n        this.onAddComponent = null;\n        this.onProgress = null;\n        this.processedCount = 0;\n        this.totalToProcess = 0;\n    }\n    getStyle(node) {\n        var _a, _b, _c;\n        const style = {\n            fill: Color4_1.default.transparent,\n        };\n        const fillAttribute = (_a = node.getAttribute('fill')) !== null && _a !== void 0 ? _a : node.style.fill;\n        if (fillAttribute) {\n            try {\n                style.fill = Color4_1.default.fromString(fillAttribute);\n            }\n            catch (e) {\n                console.error('Unknown fill color,', fillAttribute);\n            }\n        }\n        const strokeAttribute = (_b = node.getAttribute('stroke')) !== null && _b !== void 0 ? _b : node.style.stroke;\n        const strokeWidthAttr = (_c = node.getAttribute('stroke-width')) !== null && _c !== void 0 ? _c : node.style.strokeWidth;\n        if (strokeAttribute) {\n            try {\n                let width = parseFloat(strokeWidthAttr !== null && strokeWidthAttr !== void 0 ? strokeWidthAttr : '1');\n                if (!isFinite(width)) {\n                    width = 0;\n                }\n                style.stroke = {\n                    width,\n                    color: Color4_1.default.fromString(strokeAttribute),\n                };\n            }\n            catch (e) {\n                console.error('Error parsing stroke data:', e);\n            }\n        }\n        return style;\n    }\n    strokeDataFromElem(node) {\n        var _a;\n        const result = [];\n        const pathData = (_a = node.getAttribute('d')) !== null && _a !== void 0 ? _a : '';\n        const style = this.getStyle(node);\n        // Break the path into chunks at each moveTo ('M') command:\n        const parts = pathData.split('M');\n        let isFirst = true;\n        for (const part of parts) {\n            if (part !== '') {\n                // We split the path by moveTo commands, so add the 'M' back in\n                // if it was present.\n                const current = !isFirst ? `M${part}` : part;\n                const path = Path_1.default.fromString(current);\n                const spec = path.toRenderable(style);\n                result.push(spec);\n            }\n            isFirst = false;\n        }\n        return result;\n    }\n    // Adds a stroke with a single path\n    addPath(node) {\n        var _a;\n        const stroke = new Stroke_1.default(this.strokeDataFromElem(node));\n        (_a = this.onAddComponent) === null || _a === void 0 ? void 0 : _a.call(this, stroke);\n    }\n    // TODO: Remove. This method migrates users from the older (and more verbose)\n    // <group class=joplin-stroke>...</group> syntax.\n    addLegacyStroke(node) {\n        var _a;\n        const parts = [];\n        for (const child of node.children) {\n            if (child.tagName !== 'path') {\n                console.error('Encountered a node that is not a stroke:', node, '\\nChecking child', child);\n                throw new Error('node is not a stroke!');\n            }\n            parts.push(...this.strokeDataFromElem(child));\n        }\n        const stroke = new Stroke_1.default(parts);\n        (_a = this.onAddComponent) === null || _a === void 0 ? void 0 : _a.call(this, stroke);\n    }\n    addUnknownNode(node) {\n        var _a;\n        const component = new UnknownSVGObject_1.default(node);\n        (_a = this.onAddComponent) === null || _a === void 0 ? void 0 : _a.call(this, component);\n    }\n    visit(node) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.totalToProcess += node.childElementCount;\n            const legacyStrokeGroupClass = 'joplin-stroke';\n            switch (node.tagName.toLowerCase()) {\n                case 'g':\n                    if (node.classList.contains(legacyStrokeGroupClass)) {\n                        this.addLegacyStroke(node);\n                    }\n                    break;\n                case 'path':\n                    this.addPath(node);\n                    break;\n                case 'svg':\n                    (_a = this.rootViewBox) !== null && _a !== void 0 ? _a : (this.rootViewBox = (_b = node.viewBox) === null || _b === void 0 ? void 0 : _b.baseVal);\n                    break;\n                default:\n                    console.warn('Unknown SVG element,', node);\n                    if (node instanceof SVGElement) {\n                        this.addUnknownNode(node);\n                    }\n                    else {\n                        console.error('Element', node, 'is not an SVGElement!');\n                    }\n                    return;\n            }\n            for (const child of node.children) {\n                yield this.visit(child);\n            }\n            this.processedCount++;\n            yield ((_c = this.onProgress) === null || _c === void 0 ? void 0 : _c.call(this, this.processedCount, this.totalToProcess));\n        });\n    }\n    start(onAddComponent, onProgress) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.onAddComponent = onAddComponent;\n            this.onProgress = onProgress;\n            // Estimate the number of tags to process.\n            this.totalToProcess = this.source.childElementCount;\n            this.processedCount = 0;\n            this.rootViewBox = null;\n            yield this.visit(this.source);\n            const viewBox = this.rootViewBox;\n            let result = exports.defaultSVGViewRect;\n            if (viewBox) {\n                result = Rect2_1.default.of(viewBox);\n            }\n            (_a = this.onFinish) === null || _a === void 0 ? void 0 : _a.call(this);\n            return result;\n        });\n    }\n    // TODO: Handling unsafe data! Tripple-check that this is secure!\n    static fromString(text) {\n        var _a, _b;\n        const sandbox = document.createElement('iframe');\n        sandbox.src = 'about:blank';\n        sandbox.setAttribute('sandbox', 'allow-same-origin');\n        sandbox.setAttribute('csp', 'default-src \\'about:blank\\'');\n        sandbox.style.display = 'none';\n        // Required to access the frame's DOM. See https://stackoverflow.com/a/17777943/17055750\n        document.body.appendChild(sandbox);\n        if (!sandbox.hasAttribute('sandbox')) {\n            sandbox.remove();\n            throw new Error('SVG loading iframe is not sandboxed.');\n        }\n        // Try running JavaScript within the iframe\n        const sandboxDoc = (_b = (_a = sandbox.contentWindow) === null || _a === void 0 ? void 0 : _a.document) !== null && _b !== void 0 ? _b : sandbox.contentDocument;\n        sandboxDoc.open();\n        sandboxDoc.write(`\n\t\t\t<!DOCTYPE html>\n\t\t\t<html>\n\t\t\t\t<head>\n\t\t\t\t\t<title>SVG Loading Sandbox</title>\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<script>\n\t\t\t\t\t\tconsole.error('JavaScript should not be able to run here!');\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'The SVG sandbox is broken! Please double-check the sandboxing setting.'\n\t\t\t\t\t\t);\n\t\t\t\t\t</script>\n\t\t\t\t</body>\n\t\t\t</html>\n\t\t`);\n        sandboxDoc.close();\n        const svgElem = sandboxDoc.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svgElem.innerHTML = text;\n        return new SVGLoader(svgElem, () => {\n            sandbox.remove();\n        });\n    }\n}\nexports[\"default\"] = SVGLoader;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/SVGLoader.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/StrokeBuilder.ts":
/*!************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/StrokeBuilder.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst bezier_js_1 = __webpack_require__(/*! bezier-js */ \"./node_modules/bezier-js/dist/bezier.cjs\");\nconst Vec2_1 = __webpack_require__(/*! ./geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst Rect2_1 = __webpack_require__(/*! ./geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst Path_1 = __webpack_require__(/*! ./geometry/Path */ \"./components/NoteEditor/ImageEditor/geometry/Path.ts\");\nconst LineSegment2_1 = __webpack_require__(/*! ./geometry/LineSegment2 */ \"./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts\");\nconst Stroke_1 = __webpack_require__(/*! ./components/Stroke */ \"./components/NoteEditor/ImageEditor/components/Stroke.ts\");\nconst Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./components/NoteEditor/ImageEditor/Viewport.ts\");\nclass StrokeBuilder {\n    constructor(startPoint, \n    // Maximum distance from the actual curve (irrespective of stroke width)\n    // for which a point is considered 'part of the curve'.\n    // Note that the maximum will be smaller if the stroke width is less than\n    // [maxFitAllowed].\n    minFitAllowed, maxFitAllowed) {\n        this.startPoint = startPoint;\n        this.minFitAllowed = minFitAllowed;\n        this.maxFitAllowed = maxFitAllowed;\n        this.currentCurve = null;\n        this.lastPoint = this.startPoint;\n        this.segments = [];\n        this.buffer = [this.startPoint.pos];\n        this.momentum = Vec2_1.Vec2.zero;\n        this.currentCurve = null;\n        this.bbox = new Rect2_1.default(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0);\n    }\n    getBBox() {\n        return this.bbox;\n    }\n    getRenderingStyle() {\n        var _a;\n        return {\n            fill: (_a = this.lastPoint.color) !== null && _a !== void 0 ? _a : null,\n        };\n    }\n    // Get the segments that make up this' path. Can be called after calling build()\n    preview() {\n        if (this.currentCurve && this.lastPoint) {\n            const currentPath = this.currentSegmentToPath();\n            return this.segments.concat(currentPath);\n        }\n        return this.segments;\n    }\n    build() {\n        if (this.lastPoint) {\n            this.finalizeCurrentCurve();\n        }\n        return new Stroke_1.default(this.segments);\n    }\n    roundPoint(point) {\n        return Viewport_1.default.roundPoint(point, this.minFitAllowed);\n    }\n    finalizeCurrentCurve() {\n        // Case where no points have been added\n        if (!this.currentCurve) {\n            const width = Viewport_1.default.roundPoint(this.startPoint.width / 3, this.minFitAllowed);\n            const center = this.roundPoint(this.startPoint.pos);\n            // Draw a circle-ish shape around the start point\n            this.segments.push({\n                // Start on the right, cycle clockwise:\n                //    |\n                //  ----- ←\n                //    |\n                startPoint: this.startPoint.pos.plus(Vec2_1.Vec2.of(width, 0)),\n                commands: [\n                    {\n                        kind: Path_1.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(Vec2_1.Vec2.of(width, width)),\n                        // Bottom of the circle\n                        //    |\n                        //  -----\n                        //    |\n                        //    ↑\n                        endPoint: center.plus(Vec2_1.Vec2.of(0, width)),\n                    },\n                    {\n                        kind: Path_1.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(Vec2_1.Vec2.of(-width, width)),\n                        endPoint: center.plus(Vec2_1.Vec2.of(-width, 0)),\n                    },\n                    {\n                        kind: Path_1.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(Vec2_1.Vec2.of(-width, -width)),\n                        endPoint: center.plus(Vec2_1.Vec2.of(0, -width)),\n                    },\n                    {\n                        kind: Path_1.PathCommandType.QuadraticBezierTo,\n                        controlPoint: center.plus(Vec2_1.Vec2.of(width, -width)),\n                        endPoint: center.plus(Vec2_1.Vec2.of(width, 0)),\n                    },\n                ],\n                style: this.getRenderingStyle(),\n            });\n            return;\n        }\n        this.segments.push(this.currentSegmentToPath());\n        const lastPoint = this.buffer[this.buffer.length - 1];\n        this.lastExitingVec = Vec2_1.Vec2.ofXY(this.currentCurve.points[2]).minus(Vec2_1.Vec2.ofXY(this.currentCurve.points[1]));\n        console.assert(this.lastExitingVec.magnitude() != 0);\n        // Use the last two points to start a new curve (the last point isn't used\n        // in the current curve and we want connected curves to share end points)\n        this.buffer = [\n            this.buffer[this.buffer.length - 2], lastPoint,\n        ];\n        this.currentCurve = null;\n    }\n    currentSegmentToPath() {\n        let startVec = Vec2_1.Vec2.ofXY(this.currentCurve.normal(0)).normalized();\n        let endVec = Vec2_1.Vec2.ofXY(this.currentCurve.normal(1)).normalized();\n        startVec = startVec.times(this.curveStartWidth / 2);\n        endVec = endVec.times(this.curveEndWidth / 2);\n        if (isNaN(startVec.magnitude())) {\n            // TODO: This can happen when events are too close together. Find out why and\n            // \t\t fix.\n            console.error('startVec is NaN', startVec, endVec, this.currentCurve);\n            startVec = endVec;\n        }\n        const startPt = Vec2_1.Vec2.ofXY(this.currentCurve.get(0));\n        const endPt = Vec2_1.Vec2.ofXY(this.currentCurve.get(1));\n        const controlPoint = Vec2_1.Vec2.ofXY(this.currentCurve.points[1]);\n        // Approximate the normal at the location of the control point\n        const projectionT = this.currentCurve.project(controlPoint.xy).t;\n        const halfVec = Vec2_1.Vec2.ofXY(this.currentCurve.normal(projectionT))\n            .normalized().times(this.curveStartWidth / 2 * projectionT\n            + this.curveEndWidth / 2 * (1 - projectionT));\n        const pathCommands = [\n            {\n                kind: Path_1.PathCommandType.QuadraticBezierTo,\n                controlPoint: this.roundPoint(controlPoint.plus(halfVec)),\n                endPoint: this.roundPoint(endPt.plus(endVec)),\n            },\n            {\n                kind: Path_1.PathCommandType.LineTo,\n                point: this.roundPoint(endPt.minus(endVec)),\n            },\n            {\n                kind: Path_1.PathCommandType.QuadraticBezierTo,\n                controlPoint: this.roundPoint(controlPoint.minus(halfVec)),\n                endPoint: this.roundPoint(startPt.minus(startVec)),\n            },\n            {\n                kind: Path_1.PathCommandType.LineTo,\n                point: this.roundPoint(startPt.plus(startVec)),\n            },\n        ];\n        return {\n            startPoint: this.roundPoint(startPt.plus(startVec)),\n            commands: pathCommands,\n            style: this.getRenderingStyle(),\n        };\n    }\n    // Compute the direction of the velocity at the end of this.buffer\n    // Returns null if there aren't enough points to compute the vector\n    computeExitingVec() {\n        return this.momentum.normalized().times(this.lastPoint.width / 2);\n    }\n    addPoint(newPoint) {\n        var _a, _b;\n        if (this.lastPoint) {\n            // Ignore points that are identical\n            const fuzzEq = 1e-10;\n            const deltaTime = newPoint.time - this.lastPoint.time;\n            if (newPoint.pos.eq(this.lastPoint.pos, fuzzEq) || deltaTime === 0) {\n                console.warn('Discarding identical point');\n                return;\n            }\n            else if (isNaN(newPoint.pos.magnitude())) {\n                console.warn('Discarding NaN point.', newPoint);\n                return;\n            }\n            const velocity = newPoint.pos.minus(this.lastPoint.pos).times(1 / (deltaTime) * 1000);\n            this.momentum = this.momentum.lerp(velocity, 0.9);\n        }\n        const lastPoint = (_a = this.lastPoint) !== null && _a !== void 0 ? _a : newPoint;\n        this.lastPoint = newPoint;\n        this.buffer.push(newPoint.pos);\n        const pointRadius = newPoint.width / 2;\n        const prevEndWidth = this.curveEndWidth;\n        this.curveEndWidth = pointRadius;\n        // recompute bbox\n        this.bbox = this.bbox.grownToPoint(newPoint.pos, pointRadius);\n        if (this.currentCurve === null) {\n            const p1 = lastPoint.pos;\n            const p2 = lastPoint.pos.plus((_b = this.lastExitingVec) !== null && _b !== void 0 ? _b : Vec2_1.Vec2.unitX);\n            const p3 = newPoint.pos;\n            // Quadratic Bézier curve\n            this.currentCurve = new bezier_js_1.Bezier(p1.xy, p2.xy, p3.xy);\n            this.curveStartWidth = lastPoint.width / 2;\n            console.assert(!isNaN(p1.magnitude()) && !isNaN(p2.magnitude()) && !isNaN(p3.magnitude()), 'Expected !NaN');\n        }\n        let enteringVec = this.lastExitingVec;\n        if (!enteringVec) {\n            let sampleIdx = Math.ceil(this.buffer.length / 3);\n            if (sampleIdx === 0) {\n                sampleIdx = this.buffer.length - 1;\n            }\n            enteringVec = this.buffer[sampleIdx].minus(this.buffer[0]);\n        }\n        let exitingVec = this.computeExitingVec();\n        // Find the intersection between the entering vector and the exiting vector\n        const maxRelativeLength = 2;\n        const segmentStart = this.buffer[0];\n        const segmentEnd = newPoint.pos;\n        const startEndDist = segmentEnd.minus(segmentStart).magnitude();\n        const maxControlPointDist = maxRelativeLength * startEndDist;\n        // Exit in cases where we would divide by zero\n        if (maxControlPointDist === 0 || exitingVec.magnitude() === 0 || isNaN(exitingVec.magnitude())) {\n            return;\n        }\n        console.assert(!isNaN(enteringVec.magnitude()));\n        enteringVec = enteringVec.normalized();\n        exitingVec = exitingVec.normalized();\n        console.assert(!isNaN(enteringVec.magnitude()));\n        const lineFromStart = new LineSegment2_1.default(segmentStart, segmentStart.plus(enteringVec.times(maxControlPointDist)));\n        const lineFromEnd = new LineSegment2_1.default(segmentEnd.minus(exitingVec.times(maxControlPointDist)), segmentEnd);\n        const intersection = lineFromEnd.intersection(lineFromStart);\n        // Position the control point at this intersection\n        let controlPoint;\n        if (intersection) {\n            controlPoint = intersection.point;\n        }\n        else {\n            // Position the control point closer to the first -- the connecting\n            // segment will be roughly a line.\n            controlPoint = segmentStart.plus(enteringVec.times(startEndDist / 4));\n        }\n        if (isNaN(controlPoint.magnitude()) || isNaN(segmentStart.magnitude())) {\n            console.error('controlPoint is NaN', intersection, 'Start:', segmentStart, 'End:', segmentEnd, 'in:', enteringVec, 'out:', exitingVec);\n        }\n        const prevCurve = this.currentCurve;\n        this.currentCurve = new bezier_js_1.Bezier(segmentStart.xy, controlPoint.xy, segmentEnd.xy);\n        // Should we start making a new curve? Check whether all buffer points are within\n        // ±strokeWidth of the curve.\n        const curveMatchesPoints = (curve) => {\n            for (const point of this.buffer) {\n                const proj = Vec2_1.Vec2.ofXY(curve.project(point.xy));\n                const dist = proj.minus(point).magnitude();\n                const minFit = Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 2, this.minFitAllowed);\n                if (dist > minFit || dist > this.maxFitAllowed) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        if (this.buffer.length > 3) {\n            if (!curveMatchesPoints(this.currentCurve)) {\n                // Use a curve that better fits the points\n                this.currentCurve = prevCurve;\n                this.curveEndWidth = prevEndWidth;\n                // Reset the last point -- the current point was not added to the curve.\n                this.lastPoint = lastPoint;\n                this.finalizeCurrentCurve();\n                return;\n            }\n        }\n    }\n}\nexports[\"default\"] = StrokeBuilder;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/StrokeBuilder.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/UndoRedoHistory.ts":
/*!**************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/UndoRedoHistory.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass UndoRedoHistory {\n    constructor(editor) {\n        this.editor = editor;\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    /**\n     * Adds the given command to this and applies it to the editor.\n     */\n    push(command, apply = true) {\n        if (apply) {\n            command.apply(this.editor);\n        }\n        this.undoStack.push(command);\n        this.redoStack = [];\n    }\n    /**\n     * Remove the last command from this' undo stack and apply it.\n     */\n    undo() {\n        const command = this.undoStack.pop();\n        if (command) {\n            this.redoStack.push(command);\n            command.unapply(this.editor);\n        }\n    }\n    redo() {\n        const command = this.redoStack.pop();\n        if (command) {\n            this.undoStack.push(command);\n            command.apply(this.editor);\n        }\n    }\n}\nexports[\"default\"] = UndoRedoHistory;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/UndoRedoHistory.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/Viewport.ts":
/*!*******************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/Viewport.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/**\n * Represents an ImageEditor's viewable region.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Viewport = void 0;\nconst Mat33_1 = __webpack_require__(/*! ./geometry/Mat33 */ \"./components/NoteEditor/ImageEditor/geometry/Mat33.ts\");\nconst Rect2_1 = __webpack_require__(/*! ./geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst Vec3_1 = __webpack_require__(/*! ./geometry/Vec3 */ \"./components/NoteEditor/ImageEditor/geometry/Vec3.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nclass Viewport {\n    constructor(notifier) {\n        this.notifier = notifier;\n        this.resetTransform(Mat33_1.default.identity);\n        this.screenRect = Rect2_1.default.empty;\n    }\n    updateScreenSize(screenSize) {\n        this.screenRect = this.screenRect.resizedTo(screenSize);\n    }\n    get visibleRect() {\n        return this.screenRect.transformedBoundingBox(this.inverseTransform);\n    }\n    /** @return the given point, but in canvas coordinates */\n    screenToCanvas(screenPoint) {\n        return this.inverseTransform.transformVec2(screenPoint);\n    }\n    /** @return the given point, but in screen coordinates */\n    canvasToScreen(canvasPoint) {\n        return this.transform.transformVec2(canvasPoint);\n    }\n    // Updates the transformation directly. Using ViewportTransform is preferred.\n    resetTransform(newTransform) {\n        this.transform = newTransform;\n        this.inverseTransform = newTransform.inverse();\n        this.notifier.dispatch(types_1.EditorEventType.ViewportChanged, {\n            kind: types_1.EditorEventType.ViewportChanged,\n            newTransform,\n        });\n    }\n    get screenToCanvasTransform() {\n        return this.inverseTransform;\n    }\n    get canvasToScreenTransform() {\n        return this.transform;\n    }\n    // Returns the amount a vector on the canvas is scaled to become a vector on the screen.\n    getScaleFactor() {\n        // Use transformVec3 to avoid translating the vector\n        return this.transform.transformVec3(Vec3_1.default.unitX).magnitude();\n    }\n    // Returns the angle of the canvas in radians\n    getRotationAngle() {\n        return this.transform.transformVec3(Vec3_1.default.unitX).angle();\n    }\n    // The separate function type definition seems necessary here.\n    // See https://stackoverflow.com/a/58163623/17055750.\n    // eslint-disable-next-line no-dupe-class-members\n    static roundPoint(point, tolerance) {\n        const scaleFactor = Math.pow(10, Math.floor(Math.log10(tolerance)));\n        const roundComponent = (component) => {\n            return Math.round(component / scaleFactor) * scaleFactor;\n        };\n        if (typeof point === 'number') {\n            return roundComponent(point);\n        }\n        return point.map(roundComponent);\n    }\n    // Round a point with a tolerance of ±1 screen unit.\n    roundPoint(point) {\n        return Viewport.roundPoint(point, 1 / this.getScaleFactor());\n    }\n}\nexports.Viewport = Viewport;\n/**\n * Command that translates/scales the viewport.\n */\nViewport.ViewportTransform = class {\n    constructor(transform) {\n        this.transform = transform;\n        this.inverseTransform = transform.inverse();\n    }\n    apply(editor) {\n        const viewport = editor.viewport;\n        viewport.resetTransform(viewport.transform.rightMul(this.transform));\n        editor.queueRerender();\n    }\n    unapply(editor) {\n        const viewport = editor.viewport;\n        viewport.resetTransform(viewport.transform.rightMul(this.inverseTransform));\n        editor.queueRerender();\n    }\n};\nexports[\"default\"] = Viewport;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/Viewport.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/commands/Erase.ts":
/*!*************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/commands/Erase.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EditorImage_1 = __webpack_require__(/*! ../EditorImage */ \"./components/NoteEditor/ImageEditor/EditorImage.ts\");\nclass Erase {\n    constructor(toRemove) {\n        // Clone the list\n        this.toRemove = toRemove.map(elem => elem);\n    }\n    apply(editor) {\n        for (const part of this.toRemove) {\n            const parent = editor.image.findParent(part);\n            if (parent) {\n                parent.remove();\n            }\n        }\n        editor.queueRerender();\n    }\n    unapply(editor) {\n        for (const part of this.toRemove) {\n            if (!editor.image.findParent(part)) {\n                new EditorImage_1.default.AddElementCommand(part).apply(editor);\n            }\n        }\n        editor.queueRerender();\n    }\n}\nexports[\"default\"] = Erase;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/commands/Erase.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/components/AbstractComponent.ts":
/*!***************************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/components/AbstractComponent.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EditorImage_1 = __webpack_require__(/*! ../EditorImage */ \"./components/NoteEditor/ImageEditor/EditorImage.ts\");\nclass AbstractComponent {\n    constructor() {\n        this.lastChangedTime = (new Date()).getTime();\n        this.zIndex = AbstractComponent.zIndexCounter++;\n    }\n    getBBox() {\n        return this.contentBBox;\n    }\n    // Returns a command that, when applied, transforms this by [affineTransfm] and\n    // updates the editor.\n    transformBy(affineTransfm) {\n        const updateTransform = (editor, newTransfm) => {\n            // Any parent should have only one direct child.\n            const parent = editor.image.findParent(this);\n            let hadParent = false;\n            if (parent) {\n                parent.remove();\n                hadParent = true;\n            }\n            this.applyTransformation(newTransfm);\n            // Add the element back to the document.\n            if (hadParent) {\n                new EditorImage_1.default.AddElementCommand(this).apply(editor);\n            }\n        };\n        const origZIndex = this.zIndex;\n        return {\n            apply: (editor) => {\n                this.zIndex = AbstractComponent.zIndexCounter++;\n                updateTransform(editor, affineTransfm);\n                editor.queueRerender();\n            },\n            unapply: (editor) => {\n                this.zIndex = origZIndex;\n                updateTransform(editor, affineTransfm.inverse());\n                editor.queueRerender();\n            },\n        };\n    }\n}\nexports[\"default\"] = AbstractComponent;\n// Topmost z-index\nAbstractComponent.zIndexCounter = 0;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/components/AbstractComponent.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/components/Stroke.ts":
/*!****************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/components/Stroke.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Path_1 = __webpack_require__(/*! ../geometry/Path */ \"./components/NoteEditor/ImageEditor/geometry/Path.ts\");\nconst Rect2_1 = __webpack_require__(/*! ../geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst AbstractComponent_1 = __webpack_require__(/*! ./AbstractComponent */ \"./components/NoteEditor/ImageEditor/components/AbstractComponent.ts\");\nclass Stroke extends AbstractComponent_1.default {\n    constructor(parts) {\n        var _a;\n        super();\n        this.parts = parts.map(section => {\n            const path = Path_1.default.fromRenderable(section);\n            const pathBBox = this.bboxForPart(path.bbox, section.style);\n            if (!this.contentBBox) {\n                this.contentBBox = pathBBox;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(pathBBox);\n            }\n            return {\n                path,\n                bbox: pathBBox,\n                // To implement RenderablePathSpec\n                startPoint: path.startPoint,\n                style: section.style,\n                commands: path.parts,\n            };\n        });\n        (_a = this.contentBBox) !== null && _a !== void 0 ? _a : (this.contentBBox = Rect2_1.default.empty);\n    }\n    intersects(line) {\n        for (const part of this.parts) {\n            if (part.path.intersection(line).length > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    render(canvas, visibleRect) {\n        canvas.startObject(this.getBBox());\n        for (const part of this.parts) {\n            const bbox = part.bbox;\n            if (bbox.intersects(visibleRect)) {\n                canvas.drawPath(part);\n            }\n        }\n        canvas.endObject();\n    }\n    // Grows the bounding box for a given stroke part based on that part's style.\n    bboxForPart(origBBox, style) {\n        if (!style.stroke) {\n            return origBBox;\n        }\n        return origBBox.grownBy(style.stroke.width / 2);\n    }\n    applyTransformation(affineTransfm) {\n        var _a;\n        this.contentBBox = null;\n        // Update each part\n        this.parts = this.parts.map((part) => {\n            const newPath = part.path.transformedBy(affineTransfm);\n            const newBBox = this.bboxForPart(newPath.bbox, part.style);\n            if (!this.contentBBox) {\n                this.contentBBox = newBBox;\n            }\n            else {\n                this.contentBBox = this.contentBBox.union(newBBox);\n            }\n            return {\n                path: newPath,\n                bbox: newBBox,\n                startPoint: newPath.startPoint,\n                commands: newPath.parts,\n                style: part.style,\n            };\n        });\n        (_a = this.contentBBox) !== null && _a !== void 0 ? _a : (this.contentBBox = Rect2_1.default.empty);\n    }\n}\nexports[\"default\"] = Stroke;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/components/Stroke.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/components/UnknownSVGObject.ts":
/*!**************************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/components/UnknownSVGObject.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Color4_1 = __webpack_require__(/*! ../Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nconst Rect2_1 = __webpack_require__(/*! ../geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst SVGRenderer_1 = __webpack_require__(/*! ../rendering/SVGRenderer */ \"./components/NoteEditor/ImageEditor/rendering/SVGRenderer.ts\");\nconst AbstractComponent_1 = __webpack_require__(/*! ./AbstractComponent */ \"./components/NoteEditor/ImageEditor/components/AbstractComponent.ts\");\nclass UnknownSVGObject extends AbstractComponent_1.default {\n    constructor(svgObject) {\n        super();\n        this.svgObject = svgObject;\n        this.contentBBox = Rect2_1.default.of(svgObject.getBoundingClientRect());\n    }\n    render(canvas, _visibleRect) {\n        if (!(canvas instanceof SVGRenderer_1.default)) {\n            // Draw a red rectangle to represent this.\n            // TODO: Better representation of unrenderable objects.\n            canvas.drawRect(this.contentBBox, 5, { fill: Color4_1.default.red });\n            return;\n        }\n        canvas.drawSVGElem(this.svgObject);\n    }\n    intersects(lineSegment) {\n        return this.contentBBox.getEdges().some(edge => edge.intersection(lineSegment) !== null);\n    }\n    applyTransformation(_affineTransfm) {\n    }\n}\nexports[\"default\"] = UnknownSVGObject;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/components/UnknownSVGObject.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/editor.ts":
/*!*****************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/editor.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageEditor = void 0;\nconst EditorImage_1 = __webpack_require__(/*! ./EditorImage */ \"./components/NoteEditor/ImageEditor/EditorImage.ts\");\nconst ToolController_1 = __webpack_require__(/*! ./tools/ToolController */ \"./components/NoteEditor/ImageEditor/tools/ToolController.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nconst UndoRedoHistory_1 = __webpack_require__(/*! ./UndoRedoHistory */ \"./components/NoteEditor/ImageEditor/UndoRedoHistory.ts\");\nconst Viewport_1 = __webpack_require__(/*! ./Viewport */ \"./components/NoteEditor/ImageEditor/Viewport.ts\");\nconst EventDispatcher_1 = __webpack_require__(/*! @joplin/lib/EventDispatcher */ \"../lib/EventDispatcher.ts\");\nconst Vec2_1 = __webpack_require__(/*! ./geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst Vec3_1 = __webpack_require__(/*! ./geometry/Vec3 */ \"./components/NoteEditor/ImageEditor/geometry/Vec3.ts\");\nconst HTMLToolbar_1 = __webpack_require__(/*! ./toolbar/HTMLToolbar */ \"./components/NoteEditor/ImageEditor/toolbar/HTMLToolbar.ts\");\nconst Display_1 = __webpack_require__(/*! ./Display */ \"./components/NoteEditor/ImageEditor/Display.ts\");\nconst SVGRenderer_1 = __webpack_require__(/*! ./rendering/SVGRenderer */ \"./components/NoteEditor/ImageEditor/rendering/SVGRenderer.ts\");\nconst Color4_1 = __webpack_require__(/*! ./Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nconst SVGLoader_1 = __webpack_require__(/*! ./SVGLoader */ \"./components/NoteEditor/ImageEditor/SVGLoader.ts\");\n__webpack_require__(/*! ./editor.css */ \"./components/NoteEditor/ImageEditor/editor.css\");\nconst Pointer_1 = __webpack_require__(/*! ./Pointer */ \"./components/NoteEditor/ImageEditor/Pointer.ts\");\nconst Mat33_1 = __webpack_require__(/*! ./geometry/Mat33 */ \"./components/NoteEditor/ImageEditor/geometry/Mat33.ts\");\nclass ImageEditor {\n    constructor(parent, renderingMode = Display_1.RenderingMode.CanvasRenderer) {\n        this.rerenderQueued = false;\n        this.container = document.createElement('div');\n        this.renderingRegion = document.createElement('div');\n        this.container.appendChild(this.renderingRegion);\n        this.container.className = 'imageEditorContainer';\n        this.loadingWarning = document.createElement('div');\n        this.loadingWarning.classList.add('loadingMessage');\n        this.container.appendChild(this.loadingWarning);\n        this.renderingRegion.style.touchAction = 'none';\n        this.renderingRegion.className = 'imageEditorRenderArea';\n        this.renderingRegion.setAttribute('tabIndex', '0');\n        this.renderingRegion.ariaLabel = 'Image editor'; // TODO: Localize/make more descriptive\n        this.notifier = new EventDispatcher_1.default();\n        this.importExportViewport = new Viewport_1.default(this.notifier);\n        this.viewport = new Viewport_1.default(this.notifier);\n        this.display = new Display_1.default(this, renderingMode, this.renderingRegion);\n        this.image = new EditorImage_1.default();\n        this.history = new UndoRedoHistory_1.default(this);\n        this.toolController = new ToolController_1.default(this);\n        parent.appendChild(this.container);\n        // Default to a 1000x1500 image\n        this.importExportViewport.updateScreenSize(Vec2_1.Vec2.of(1000, 1500));\n        this.viewport.updateScreenSize(Vec2_1.Vec2.of(this.display.width, this.display.height));\n        this.registerListeners();\n        this.rerender();\n        this.hideLoadingWarning();\n    }\n    showLoadingWarning(fractionLoaded) {\n        const loadingPercent = Math.round(fractionLoaded * 100);\n        this.loadingWarning.innerText = `Loading... ${loadingPercent}%`; // TODO: Localize!\n        this.loadingWarning.style.display = 'block';\n    }\n    hideLoadingWarning() {\n        this.loadingWarning.style.display = 'none';\n    }\n    addToolbar() {\n        return new HTMLToolbar_1.default(this, this.container);\n    }\n    registerListeners() {\n        const pointers = {};\n        const getPointerList = () => {\n            const nowTime = (new Date()).getTime();\n            const res = [];\n            for (const id in pointers) {\n                const maxUnupdatedTime = 2000; // Maximum time without a pointer update (ms)\n                if (pointers[id] && (nowTime - pointers[id].timeStamp) < maxUnupdatedTime) {\n                    res.push(pointers[id]);\n                }\n            }\n            return res;\n        };\n        // May be required to prevent text selection on iOS/Safari:\n        // See https://stackoverflow.com/a/70992717/17055750\n        this.renderingRegion.addEventListener('touchstart', evt => evt.preventDefault());\n        this.renderingRegion.addEventListener('pointerdown', evt => {\n            const pointer = Pointer_1.default.ofEvent(evt, true, this.viewport);\n            pointers[pointer.id] = pointer;\n            this.renderingRegion.setPointerCapture(pointer.id);\n            const event = {\n                kind: types_1.InputEvtType.PointerDownEvt,\n                current: pointer,\n                allPointers: getPointerList(),\n            };\n            this.toolController.dispatchInputEvent(event);\n            return true;\n        });\n        this.renderingRegion.addEventListener('pointermove', evt => {\n            var _a, _b;\n            const pointer = Pointer_1.default.ofEvent(evt, (_b = (_a = pointers[evt.pointerId]) === null || _a === void 0 ? void 0 : _a.down) !== null && _b !== void 0 ? _b : false, this.viewport);\n            if (pointer.down) {\n                pointers[pointer.id] = pointer;\n                if (this.toolController.dispatchInputEvent({\n                    kind: types_1.InputEvtType.PointerMoveEvt,\n                    current: pointer,\n                    allPointers: getPointerList(),\n                })) {\n                    evt.preventDefault();\n                }\n            }\n        });\n        const pointerEnd = (evt) => {\n            const pointer = Pointer_1.default.ofEvent(evt, false, this.viewport);\n            if (!pointers[pointer.id]) {\n                return;\n            }\n            pointers[pointer.id] = pointer;\n            this.renderingRegion.releasePointerCapture(pointer.id);\n            if (this.toolController.dispatchInputEvent({\n                kind: types_1.InputEvtType.PointerUpEvt,\n                current: pointer,\n                allPointers: getPointerList(),\n            })) {\n                evt.preventDefault();\n            }\n            delete pointers[pointer.id];\n        };\n        this.renderingRegion.addEventListener('pointerup', evt => {\n            pointerEnd(evt);\n        });\n        this.renderingRegion.addEventListener('pointercancel', evt => {\n            pointerEnd(evt);\n        });\n        this.renderingRegion.addEventListener('keydown', evt => {\n            if (this.toolController.dispatchInputEvent({\n                kind: types_1.InputEvtType.KeyPressEvent,\n                key: evt.key,\n            })) {\n                evt.preventDefault();\n            }\n        });\n        this.container.addEventListener('wheel', evt => {\n            let delta = Vec3_1.default.of(evt.deltaX, evt.deltaY, evt.deltaZ);\n            if (evt.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n                delta = delta.times(15);\n            }\n            else if (evt.deltaMode === WheelEvent.DOM_DELTA_PAGE) {\n                delta = delta.times(100);\n            }\n            if (evt.ctrlKey) {\n                delta = Vec3_1.default.of(0, 0, evt.deltaY);\n            }\n            const pos = Vec2_1.Vec2.of(evt.clientX, evt.clientY);\n            if (this.toolController.dispatchInputEvent({\n                kind: types_1.InputEvtType.WheelEvt,\n                delta,\n                screenPos: pos,\n            })) {\n                evt.preventDefault();\n                return true;\n            }\n            return false;\n        });\n        window.addEventListener('resize', () => {\n            this.notifier.dispatch(types_1.EditorEventType.DisplayResized, {\n                kind: types_1.EditorEventType.DisplayResized,\n                newSize: Vec2_1.Vec2.of(this.display.width, this.display.height),\n            });\n            this.viewport.updateScreenSize(Vec2_1.Vec2.of(this.display.width, this.display.height));\n            this.queueRerender();\n        });\n    }\n    dispatch(command) {\n        // .push applies [command] to this\n        this.history.push(command);\n    }\n    queueRerender() {\n        if (!this.rerenderQueued) {\n            this.rerenderQueued = true;\n            requestAnimationFrame(() => {\n                this.rerender();\n                this.rerenderQueued = false;\n            });\n        }\n    }\n    rerender() {\n        this.display.startRerender();\n        // Draw a rectangle around the region that will be visible on save\n        const renderer = this.display.getDryInkRenderer();\n        const exportRectFill = { fill: Color4_1.default.fromHex('#44444455') };\n        const exportRectStrokeWidth = 12;\n        renderer.drawRect(this.importExportViewport.visibleRect, exportRectStrokeWidth, exportRectFill);\n        this.image.render(renderer, this.viewport);\n        this.rerenderQueued = false;\n    }\n    drawWetInk(...path) {\n        for (const part of path) {\n            this.display.getWetInkRenderer().drawPath(part);\n        }\n    }\n    clearWetInk() {\n        this.display.getWetInkRenderer().clear();\n    }\n    createHTMLOverlay(overlay) {\n        overlay.classList.add('overlay');\n        this.container.appendChild(overlay);\n        return {\n            remove: () => overlay.remove(),\n        };\n    }\n    addStyleSheet(content) {\n        const styleSheet = document.createElement('style');\n        styleSheet.innerText = content;\n        this.container.appendChild(styleSheet);\n        return styleSheet;\n    }\n    // Dispatch a pen event to the currently selected tool.\n    // Intented for unit tests.\n    sendPenEvent(eventType, point, allPointers) {\n        const mainPointer = Pointer_1.default.ofCanvasPoint(point, eventType !== types_1.InputEvtType.PointerUpEvt, this.viewport);\n        this.toolController.dispatchInputEvent({\n            kind: eventType,\n            allPointers: allPointers !== null && allPointers !== void 0 ? allPointers : [\n                mainPointer,\n            ],\n            current: mainPointer,\n        });\n    }\n    toSVG() {\n        const viewport = this.importExportViewport;\n        const svgNameSpace = 'http://www.w3.org/2000/svg';\n        const result = document.createElementNS(svgNameSpace, 'svg');\n        const renderer = new SVGRenderer_1.default(result, viewport);\n        // Render **all** elements.\n        this.image.renderAll(renderer);\n        // Just show the main region\n        const rect = viewport.visibleRect;\n        result.setAttribute('viewBox', `${rect.x} ${rect.y} ${rect.w} ${rect.h}`);\n        result.setAttribute('width', `${rect.w}`);\n        result.setAttribute('height', `${rect.w}`);\n        // Ensure the image can be identified as an SVG if downloaded.\n        // See https://jwatt.org/svg/authoring/\n        result.setAttribute('version', '1.1');\n        result.setAttribute('baseProfile', 'full');\n        result.setAttribute('xmlns', svgNameSpace);\n        return result;\n    }\n    loadFrom(loader) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.showLoadingWarning(0);\n            const visibleRect = yield loader.start((component) => {\n                (new EditorImage_1.default.AddElementCommand(component)).apply(this);\n            }, (countProcessed, totalToProcess) => {\n                if (countProcessed % 100 === 0) {\n                    this.showLoadingWarning(countProcessed / totalToProcess);\n                    this.rerender();\n                    return new Promise(resolve => {\n                        requestAnimationFrame(() => resolve());\n                    });\n                }\n                return null;\n            });\n            this.hideLoadingWarning();\n            this.importExportViewport.updateScreenSize(visibleRect.size);\n            this.importExportViewport.resetTransform(Mat33_1.default.translation(visibleRect.topLeft));\n        });\n    }\n    // Alias for loadFrom(SVGLoader.fromString).\n    // This is particularly useful when accessing a bundled version of the editor.\n    loadFromSVG(svgData) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const loader = SVGLoader_1.default.fromString(svgData);\n            yield this.loadFrom(loader);\n        });\n    }\n}\nexports.ImageEditor = ImageEditor;\nexports[\"default\"] = ImageEditor;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/editor.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts":
/*!********************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Rect2_1 = __webpack_require__(/*! ./Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst Vec2_1 = __webpack_require__(/*! ./Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nclass LineSegment2 {\n    constructor(point1, point2) {\n        this.point1 = point1;\n        this.point2 = point2;\n        this.bbox = Rect2_1.default.bboxOf([point1, point2]);\n        this.direction = point2.minus(point1);\n        this.length = this.direction.magnitude();\n        // Normalize\n        if (this.length > 0) {\n            this.direction = this.direction.times(1 / this.length);\n        }\n    }\n    // Accessors to make LineSegment2 compatible with bezier-js's\n    // interface\n    get p1() {\n        return this.point1;\n    }\n    get p2() {\n        return this.point2;\n    }\n    get(t) {\n        return this.point1.plus(this.direction.times(t));\n    }\n    intersection(other) {\n        // We want x₁(t) = x₂(t) and y₁(t) = y₂(t)\n        // Observe that\n        // x = this.point1.x + this.direction.x · t₁\n        //   = other.point1.x + other.direction.x · t₂\n        // Thus,\n        //  t₁ = (x - this.point1.x) / this.direction.x\n        //     = (y - this.point1.y) / this.direction.y\n        // and\n        //  t₂ = (x - other.point1.x) / other.direction.x\n        // (and similarly for y)\n        //\n        // Letting o₁ₓ = this.point1.x, o₂ₓ = other.point1.x,\n        //         d₁ᵧ = this.direction.y, ...\n        //\n        // We can substitute these into the equations for y:\n        // y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ\n        //   = o₂ᵧ + d₂ᵧ · (x - o₂ₓ) / d₂ₓ\n        // ⇒ o₁ᵧ - o₂ᵧ = d₂ᵧ · (x - o₂ₓ) / d₂ₓ - d₁ᵧ · (x - o₁ₓ) / d₁ₓ\n        //            = (d₂ᵧ/d₂ₓ)(x) - (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(x) + (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        //            = (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) - (d₂ᵧ/d₂ₓ)(o₂ₓ) + (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        // ⇒ (x)(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ) = o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ)\n        // ⇒ x = (o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧ/d₂ₓ - d₁ᵧ/d₁ₓ)\n        //     = (d₁ₓd₂ₓ)(o₁ᵧ - o₂ᵧ + (d₂ᵧ/d₂ₓ)(o₂ₓ) - (d₁ᵧ/d₁ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n        //     = ((o₁ᵧ - o₂ᵧ)((d₁ₓd₂ₓ)) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n        // ⇒ y = o₁ᵧ + d₁ᵧ · (x - o₁ₓ) / d₁ₓ = ...\n        let resultPoint, resultT;\n        if (this.direction.x === 0) {\n            // Vertical line: Where does the other have x = this.point1.x?\n            // x = o₁ₓ = o₂ₓ + d₂ₓ · (y - o₂ᵧ) / d₂ᵧ\n            // ⇒ (o₁ₓ - o₂ₓ)(d₂ᵧ/d₂ₓ) + o₂ᵧ = y\n            // Avoid division by zero\n            if (other.direction.x === 0 || this.direction.y === 0) {\n                return null;\n            }\n            const xIntersect = this.point1.x;\n            const yIntersect = (this.point1.x - other.point1.x) * other.direction.y / other.direction.x + other.point1.y;\n            resultPoint = Vec2_1.Vec2.of(xIntersect, yIntersect);\n            resultT = (yIntersect - this.point1.y) / this.direction.y;\n        }\n        else {\n            // From above,\n            // x = ((o₁ᵧ - o₂ᵧ)(d₁ₓd₂ₓ) + (d₂ᵧd₁ₓ)(o₂ₓ) - (d₁ᵧd₂ₓ)(o₁ₓ))/(d₂ᵧd₁ₓ - d₁ᵧd₂ₓ)\n            const numerator = ((this.point1.y - other.point1.y) * this.direction.x * other.direction.x\n                + this.direction.x * other.direction.y * other.point1.x\n                - this.direction.y * other.direction.x * this.point1.x);\n            const denominator = (other.direction.y * this.direction.x\n                - this.direction.y * other.direction.x);\n            // Avoid dividing by zero. It means there is no intersection\n            if (denominator === 0) {\n                return null;\n            }\n            const xIntersect = numerator / denominator;\n            const t1 = (xIntersect - this.point1.x) / this.direction.x;\n            const yIntersect = this.point1.y + this.direction.y * t1;\n            resultPoint = Vec2_1.Vec2.of(xIntersect, yIntersect);\n            resultT = (xIntersect - this.point1.x) / this.direction.x;\n        }\n        // Ensure the result is in this/the other segment.\n        const resultToP1 = resultPoint.minus(this.point1).magnitude();\n        const resultToP2 = resultPoint.minus(this.point2).magnitude();\n        const resultToP3 = resultPoint.minus(other.point1).magnitude();\n        const resultToP4 = resultPoint.minus(other.point2).magnitude();\n        if (resultToP1 > this.length\n            || resultToP2 > this.length\n            || resultToP3 > other.length\n            || resultToP4 > other.length) {\n            return null;\n        }\n        return {\n            point: resultPoint,\n            t: resultT,\n        };\n    }\n}\nexports[\"default\"] = LineSegment2;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/geometry/Mat33.ts":
/*!*************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/geometry/Mat33.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Vec2_1 = __webpack_require__(/*! ./Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst Vec3_1 = __webpack_require__(/*! ./Vec3 */ \"./components/NoteEditor/ImageEditor/geometry/Vec3.ts\");\n/**\n * Represents a three dimensional linear transformation or\n * a two-dimensional affine transformation.\n */\nclass Mat33 {\n    constructor(a1, a2, a3, b1, b2, b3, c1, c2, c3) {\n        this.a1 = a1;\n        this.a2 = a2;\n        this.a3 = a3;\n        this.b1 = b1;\n        this.b2 = b2;\n        this.b3 = b3;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.c3 = c3;\n        this.cachedInverse = undefined;\n        this.rows = [\n            Vec3_1.default.of(a1, a2, a3),\n            Vec3_1.default.of(b1, b2, b3),\n            Vec3_1.default.of(c1, c2, c3),\n        ];\n    }\n    static ofRows(r1, r2, r3) {\n        return new Mat33(r1.x, r1.y, r1.z, r2.x, r2.y, r2.z, r3.x, r3.y, r3.z);\n    }\n    // Either returns the inverse of this, or, if this matrix is singular/uninvertable,\n    // returns Mat33.identity.\n    inverse() {\n        var _a;\n        return (_a = this.computeInverse()) !== null && _a !== void 0 ? _a : Mat33.identity;\n    }\n    invertable() {\n        return this.computeInverse() !== null;\n    }\n    computeInverse() {\n        if (this.cachedInverse !== undefined) {\n            return this.cachedInverse;\n        }\n        const toIdentity = [\n            this.rows[0],\n            this.rows[1],\n            this.rows[2],\n        ];\n        const toResult = [\n            Vec3_1.default.unitX,\n            Vec3_1.default.unitY,\n            Vec3_1.default.unitZ,\n        ];\n        // Convert toIdentity to the identity matrix and\n        // toResult to the inverse through elementary row operations\n        for (let cursor = 0; cursor < 3; cursor++) {\n            // Select the [cursor]th diagonal entry\n            let pivot = toIdentity[cursor].at(cursor);\n            // Don't divide by zero (treat very small numbers as zero).\n            const minDivideBy = 1e-10;\n            if (Math.abs(pivot) < minDivideBy) {\n                let swapIndex = -1;\n                // For all other rows,\n                for (let i = 1; i <= 2; i++) {\n                    const otherRowIdx = (cursor + i) % 3;\n                    if (Math.abs(toIdentity[otherRowIdx].at(cursor)) >= minDivideBy) {\n                        swapIndex = otherRowIdx;\n                        break;\n                    }\n                }\n                // Can't swap with another row?\n                if (swapIndex === -1) {\n                    this.cachedInverse = null;\n                    return null;\n                }\n                const tmpIdentityRow = toIdentity[cursor];\n                const tmpResultRow = toResult[cursor];\n                // Swap!\n                toIdentity[cursor] = toIdentity[swapIndex];\n                toResult[cursor] = toResult[swapIndex];\n                toIdentity[swapIndex] = tmpIdentityRow;\n                toResult[swapIndex] = tmpResultRow;\n                pivot = toIdentity[cursor].at(cursor);\n            }\n            // Make toIdentity[k = cursor] = 1\n            let scale = 1.0 / pivot;\n            toIdentity[cursor] = toIdentity[cursor].times(scale);\n            toResult[cursor] = toResult[cursor].times(scale);\n            const cursorToIdentityRow = toIdentity[cursor];\n            const cursorToResultRow = toResult[cursor];\n            // Make toIdentity[k ≠ cursor] = 0\n            for (let i = 1; i <= 2; i++) {\n                const otherRowIdx = (cursor + i) % 3;\n                scale = -toIdentity[otherRowIdx].at(cursor);\n                toIdentity[otherRowIdx] = toIdentity[otherRowIdx].plus(cursorToIdentityRow.times(scale));\n                toResult[otherRowIdx] = toResult[otherRowIdx].plus(cursorToResultRow.times(scale));\n            }\n        }\n        const inverse = Mat33.ofRows(toResult[0], toResult[1], toResult[2]);\n        this.cachedInverse = inverse;\n        return inverse;\n    }\n    /** @return thisᵀ */\n    transposed() {\n        return new Mat33(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3);\n    }\n    /** @return (this)(other) */\n    rightMul(other) {\n        other = other.transposed();\n        const at = (row, col) => {\n            return this.rows[row].dot(other.rows[col]);\n        };\n        return new Mat33(at(0, 0), at(0, 1), at(0, 2), at(1, 0), at(1, 1), at(1, 2), at(2, 0), at(2, 1), at(2, 2));\n    }\n    /**\n     * Treat the given vector like a Vec2. Applies this as an affine transformation\n     * to the given vector.\n     *\n     * @return the transformed vector.\n     */\n    transformVec2(other) {\n        // When transforming a Vec2, we want to use the z transformation\n        // components of this for translation:\n        //  ⎡ . . tX ⎤\n        //  ⎢ . . tY ⎥\n        //  ⎣ 0 0 1  ⎦\n        // For this, we need other's z component to be 1 (so that tX and tY\n        // are scaled by 1):\n        let intermediate = Vec3_1.default.of(other.x, other.y, 1);\n        intermediate = this.transformVec3(intermediate);\n        // Drop the z=1 to allow magnitude to work as expected\n        return Vec2_1.Vec2.of(intermediate.x, intermediate.y);\n    }\n    /** @returns the right multiplication of this with other */\n    transformVec3(other) {\n        return Vec3_1.default.of(this.rows[0].dot(other), this.rows[1].dot(other), this.rows[2].dot(other));\n    }\n    /** @returns true iff this = other ± fuzz */\n    eq(other, fuzz = 0) {\n        for (let i = 0; i < 3; i++) {\n            if (!this.rows[i].eq(other.rows[i], fuzz)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        return `\n⎡ ${this.a1},\\t ${this.a2},\\t ${this.a3}\\t ⎤\n⎢ ${this.b1},\\t ${this.b2},\\t ${this.b3}\\t ⎥\n⎣ ${this.c1},\\t ${this.c2},\\t ${this.c3}\\t ⎦\n\t\t`.trimRight();\n    }\n    /**\n     * @return a 1D array where [0] corresponds to the\n     * top-left element, [1] corresponds to the element\n     * at [0,1] (row zero, column 1) and [5] corresponds\n     * to the element at [1,2].\n     */\n    toArray() {\n        return [\n            this.a1, this.a2, this.a3,\n            this.b1, this.b2, this.b3,\n            this.c1, this.c2, this.c3,\n        ];\n    }\n    /**\n     * @return a 3x3 translation matrix. When transforming a Vec2,\n     *    that Vec2 will be translated by [amount].\n     */\n    static translation(amount) {\n        // When transforming Vec2s by a 3x3 matrix, we give the input\n        // Vec2s z = 1. As such,\n        //   outVec2.x = inVec2.x * 1 + inVec2.y * 0 + 1 * amount.x\n        //   ...\n        return new Mat33(1, 0, amount.x, 0, 1, amount.y, 0, 0, 1);\n    }\n    /**\n     * @return a rotation matrix that rotates [radians] about the\n     *     z-axis.\n     */\n    static zRotation(radians, center = Vec2_1.Vec2.zero) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        // Translate everything so that rotation is about the origin\n        let result = Mat33.translation(center);\n        result = result.rightMul(new Mat33(cos, -sin, 0, sin, cos, 0, 0, 0, 1));\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n    /** @return a transform that scales X and Y by [amount] */\n    static scaling2D(amount, center = Vec2_1.Vec2.zero) {\n        let result = Mat33.translation(center);\n        let xAmount, yAmount;\n        if (typeof amount === 'number') {\n            xAmount = amount;\n            yAmount = amount;\n        }\n        else {\n            xAmount = amount.x;\n            yAmount = amount.y;\n        }\n        result = result.rightMul(new Mat33(xAmount, 0, 0, 0, yAmount, 0, 0, 0, 1));\n        // Translate such that [center] goes to (0, 0)\n        return result.rightMul(Mat33.translation(center.times(-1)));\n    }\n}\nexports[\"default\"] = Mat33;\nMat33.identity = new Mat33(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/geometry/Mat33.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/geometry/Path.ts":
/*!************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/geometry/Path.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathCommandType = void 0;\nconst bezier_js_1 = __webpack_require__(/*! bezier-js */ \"./node_modules/bezier-js/dist/bezier.cjs\");\nconst LineSegment2_1 = __webpack_require__(/*! ./LineSegment2 */ \"./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts\");\nconst Rect2_1 = __webpack_require__(/*! ./Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst Vec2_1 = __webpack_require__(/*! ./Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nvar PathCommandType;\n(function (PathCommandType) {\n    PathCommandType[PathCommandType[\"LineTo\"] = 0] = \"LineTo\";\n    PathCommandType[PathCommandType[\"MoveTo\"] = 1] = \"MoveTo\";\n    PathCommandType[PathCommandType[\"CubicBezierTo\"] = 2] = \"CubicBezierTo\";\n    PathCommandType[PathCommandType[\"QuadraticBezierTo\"] = 3] = \"QuadraticBezierTo\";\n})(PathCommandType = exports.PathCommandType || (exports.PathCommandType = {}));\nclass Path {\n    constructor(startPoint, parts) {\n        this.startPoint = startPoint;\n        this.parts = parts;\n        this.cachedGeometry = null;\n        // Initial bounding box contains one point: the start point.\n        this.bbox = Rect2_1.default.bboxOf([startPoint]);\n        // Convert into a representation of the geometry (cache for faster intersection\n        // calculation)\n        for (const part of parts) {\n            this.bbox = this.bbox.union(Path.computeBBoxForSegment(startPoint, part));\n        }\n    }\n    // Lazy-loads and returns this path's geometry\n    get geometry() {\n        if (this.cachedGeometry) {\n            return this.cachedGeometry;\n        }\n        let startPoint = this.startPoint;\n        const geometry = [];\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.CubicBezierTo:\n                    geometry.push(new bezier_js_1.Bezier(startPoint.xy, part.controlPoint1.xy, part.controlPoint2.xy, part.endPoint.xy));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    geometry.push(new bezier_js_1.Bezier(startPoint.xy, part.controlPoint.xy, part.endPoint.xy));\n                    startPoint = part.endPoint;\n                    break;\n                case PathCommandType.LineTo:\n                    geometry.push(new LineSegment2_1.default(startPoint, part.point));\n                    startPoint = part.point;\n                    break;\n                case PathCommandType.MoveTo:\n                    startPoint = part.point;\n                    break;\n            }\n        }\n        this.cachedGeometry = geometry;\n        return this.cachedGeometry;\n    }\n    static computeBBoxForSegment(startPoint, part) {\n        const points = [startPoint];\n        let exhaustivenessCheck;\n        switch (part.kind) {\n            case PathCommandType.MoveTo:\n            case PathCommandType.LineTo:\n                points.push(part.point);\n                break;\n            case PathCommandType.CubicBezierTo:\n                points.push(part.controlPoint1, part.controlPoint2, part.endPoint);\n                break;\n            case PathCommandType.QuadraticBezierTo:\n                points.push(part.controlPoint, part.endPoint);\n                break;\n            default:\n                exhaustivenessCheck = part;\n                return exhaustivenessCheck;\n        }\n        return Rect2_1.default.bboxOf(points);\n    }\n    intersection(line) {\n        const result = [];\n        for (const part of this.geometry) {\n            if (part instanceof LineSegment2_1.default) {\n                const intersection = part.intersection(line);\n                if (intersection) {\n                    result.push({\n                        curve: part,\n                        parameterValue: intersection.t,\n                        point: intersection.point,\n                    });\n                }\n            }\n            else {\n                const intersectionPoints = part.intersects(line).map(t => {\n                    // We're using the .intersects(line) function, which is documented\n                    // to always return numbers. However, to satisfy the type checker (and\n                    // possibly improperly-defined types),\n                    if (typeof t === 'string') {\n                        t = parseFloat(t);\n                    }\n                    const point = Vec2_1.Vec2.ofXY(part.get(t));\n                    // Ensure that the intersection is on the line\n                    if (point.minus(line.p1).magnitude() > line.length\n                        || point.minus(line.p2).magnitude() > line.length) {\n                        return null;\n                    }\n                    return {\n                        point,\n                        parameterValue: t,\n                        curve: part,\n                    };\n                }).filter(entry => entry !== null);\n                result.push(...intersectionPoints);\n            }\n        }\n        return result;\n    }\n    transformedBy(affineTransfm) {\n        const startPoint = affineTransfm.transformVec2(this.startPoint);\n        const newParts = [];\n        let exhaustivenessCheck;\n        for (const part of this.parts) {\n            switch (part.kind) {\n                case PathCommandType.MoveTo:\n                case PathCommandType.LineTo:\n                    newParts.push({\n                        kind: part.kind,\n                        point: affineTransfm.transformVec2(part.point),\n                    });\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint1: affineTransfm.transformVec2(part.controlPoint1),\n                        controlPoint2: affineTransfm.transformVec2(part.controlPoint2),\n                        endPoint: affineTransfm.transformVec2(part.endPoint),\n                    });\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    newParts.push({\n                        kind: part.kind,\n                        controlPoint: affineTransfm.transformVec2(part.controlPoint),\n                        endPoint: affineTransfm.transformVec2(part.endPoint),\n                    });\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        return new Path(startPoint, newParts);\n    }\n    // Creates a new path by joining [other] to the end of this path\n    union(other) {\n        if (!other) {\n            return this;\n        }\n        return new Path(this.startPoint, [\n            ...this.parts,\n            {\n                kind: PathCommandType.MoveTo,\n                point: other.startPoint,\n            },\n            ...other.parts,\n        ]);\n    }\n    static fromRenderable(renderable) {\n        return new Path(renderable.startPoint, renderable.commands);\n    }\n    toRenderable(fill) {\n        return {\n            startPoint: this.startPoint,\n            style: fill,\n            commands: this.parts,\n        };\n    }\n    toString() {\n        return Path.toString(this.startPoint, this.parts);\n    }\n    static toString(startPoint, parts) {\n        const result = [];\n        const toRoundedString = (num) => {\n            // Try to remove rounding errors. If the number ends in at least three/four zeroes\n            // (or nines) just one or two digits, it's probably a rounding error.\n            const fixRoundingUpExp = /^([-]?\\d*\\.?\\d*[1-9.])0{4,}\\d$/;\n            const hasRoundingDownExp = /^([-]?)(\\d*)\\.(\\d*9{4,}\\d)$/;\n            let text = num.toString();\n            if (text.indexOf('.') === -1) {\n                return text;\n            }\n            const roundingDownMatch = hasRoundingDownExp.exec(text);\n            if (roundingDownMatch) {\n                const negativeSign = roundingDownMatch[1];\n                const lastDigit = parseInt(text.charAt(text.length - 1), 10);\n                const postDecimal = parseInt(roundingDownMatch[3], 10);\n                const preDecimal = parseInt(roundingDownMatch[2], 10);\n                let newPostDecimal = (postDecimal + 10 - lastDigit).toString();\n                let carry = 0;\n                if (newPostDecimal.length > postDecimal.toString().length) {\n                    // Left-shift\n                    newPostDecimal = newPostDecimal.substring(1);\n                    carry = 1;\n                }\n                text = `${negativeSign + (preDecimal + carry).toString()}.${newPostDecimal}`;\n            }\n            text = text.replace(fixRoundingUpExp, '$1');\n            // Remove trailing period (if it exists)\n            return text.replace(/[.]$/, '');\n        };\n        const addCommand = (command, ...points) => {\n            const parts = [];\n            for (const point of points) {\n                const xComponent = toRoundedString(point.x);\n                const yComponent = toRoundedString(point.y);\n                parts.push(`${xComponent},${yComponent}`);\n            }\n            result.push(`${command}${parts.join(' ')}`);\n        };\n        addCommand('M', startPoint);\n        let exhaustivenessCheck;\n        for (const part of parts) {\n            switch (part.kind) {\n                case PathCommandType.MoveTo:\n                    addCommand('M', part.point);\n                    break;\n                case PathCommandType.LineTo:\n                    addCommand('L', part.point);\n                    break;\n                case PathCommandType.CubicBezierTo:\n                    addCommand('C', part.controlPoint1, part.controlPoint2, part.endPoint);\n                    break;\n                case PathCommandType.QuadraticBezierTo:\n                    addCommand('Q', part.controlPoint, part.endPoint);\n                    break;\n                default:\n                    exhaustivenessCheck = part;\n                    return exhaustivenessCheck;\n            }\n        }\n        return result.join('');\n    }\n    // Create a Path from a SVG path specification.\n    // TODO: Support a larger subset of SVG paths.\n    // TODO: Support h,v,s,t shorthands.\n    static fromString(pathString) {\n        // See the MDN reference:\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n        // and\n        // https://www.w3.org/TR/SVG2/paths.html\n        // Remove linebreaks\n        pathString = pathString.split('\\n').join(' ');\n        // TODO: Check default initializer\n        let lastPos = Vec2_1.Vec2.zero;\n        let firstPos = null;\n        const commands = [];\n        const moveTo = (point) => {\n            commands.push({\n                kind: PathCommandType.MoveTo,\n                point,\n            });\n        };\n        const lineTo = (point) => {\n            commands.push({\n                kind: PathCommandType.LineTo,\n                point,\n            });\n        };\n        const cubicBezierTo = (cp1, cp2, end) => {\n            commands.push({\n                kind: PathCommandType.CubicBezierTo,\n                controlPoint1: cp1,\n                controlPoint2: cp2,\n                endPoint: end,\n            });\n        };\n        const quadraticBeierTo = (controlPoint, endPoint) => {\n            commands.push({\n                kind: PathCommandType.QuadraticBezierTo,\n                controlPoint,\n                endPoint,\n            });\n        };\n        // Each command: Command character followed by anything that isn't a command character\n        const commandExp = /([MmZzLlHhVvCcSsQqTtAa])\\s*([^a-zA-Z]*)/g;\n        let current;\n        while ((current = commandExp.exec(pathString)) !== null) {\n            const commandChar = current[1];\n            const argParts = current[2].trim().split(/[^0-9.-]/);\n            // Convert arguments to points\n            const args = argParts.filter(part => part.length > 0).reduce((accumulator, current, index, parts) => {\n                if (index % 2 !== 0) {\n                    const currentAsFloat = parseFloat(current);\n                    const prevAsFloat = parseFloat(parts[index - 1]);\n                    return accumulator.concat(Vec2_1.Vec2.of(prevAsFloat, currentAsFloat));\n                }\n                else {\n                    return accumulator;\n                }\n            }, []).map((coordinate) => {\n                const uppercaseCommand = commandChar !== commandChar.toLowerCase();\n                // Lowercase commands are relative, uppercase commands use absolute\n                // positioning\n                if (uppercaseCommand) {\n                    lastPos = coordinate;\n                    return coordinate;\n                }\n                else {\n                    lastPos = lastPos.plus(coordinate);\n                    return lastPos;\n                }\n            });\n            let expectedArgsCount;\n            switch (commandChar.toLowerCase()) {\n                case 'm':\n                    expectedArgsCount = 1;\n                    moveTo(args[0]);\n                    break;\n                case 'l':\n                    expectedArgsCount = 1;\n                    lineTo(args[0]);\n                    break;\n                case 'z':\n                    expectedArgsCount = 0;\n                    lineTo(firstPos);\n                    // TODO: Consider case where firstPos is null\n                    break;\n                case 'c':\n                    expectedArgsCount = 3;\n                    cubicBezierTo(args[0], args[1], args[2]);\n                    break;\n                case 'q':\n                    expectedArgsCount = 2;\n                    quadraticBeierTo(args[0], args[1]);\n                    break;\n                default:\n                    throw new Error(`Unknown path command ${commandChar}`);\n            }\n            if (args.length !== expectedArgsCount) {\n                throw new Error(`\n\t\t\t\t\tIncorrect number of arguments: got ${JSON.stringify(args)} with a length of ${args.length} ≠ ${expectedArgsCount}.\n\t\t\t\t`.trim());\n            }\n            if (args.length > 0) {\n                firstPos !== null && firstPos !== void 0 ? firstPos : (firstPos = args[0]);\n            }\n        }\n        return new Path(firstPos !== null && firstPos !== void 0 ? firstPos : Vec2_1.Vec2.zero, commands);\n    }\n}\nexports[\"default\"] = Path;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/geometry/Path.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/geometry/Rect2.ts":
/*!*************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/geometry/Rect2.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst LineSegment2_1 = __webpack_require__(/*! ./LineSegment2 */ \"./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts\");\nconst Vec2_1 = __webpack_require__(/*! ./Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\n/**\n * Represents a rectangle.\n *\n * invariant: w > 0, h > 0.\n */\nclass Rect2 {\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n        if (w < 0) {\n            this.x += w;\n            this.w = Math.abs(w);\n        }\n        if (h < 0) {\n            this.y += h;\n            this.h = Math.abs(h);\n        }\n        // Precompute/store vector forms.\n        this.topLeft = Vec2_1.Vec2.of(this.x, this.y);\n        this.size = Vec2_1.Vec2.of(this.w, this.h);\n        this.bottomRight = this.topLeft.plus(this.size);\n        this.center = this.topLeft.plus(this.size.times(0.5));\n        this.area = this.w * this.h;\n    }\n    translatedBy(vec) {\n        return new Rect2(vec.x + this.x, vec.y + this.y, this.w, this.h);\n    }\n    resizedTo(size) {\n        return new Rect2(this.x, this.y, size.x, size.y);\n    }\n    containsPoint(other) {\n        return this.x <= other.x && this.y <= other.y\n            && this.x + this.w >= other.x && this.y + this.h >= other.y;\n    }\n    containsRect(other) {\n        return this.x <= other.x && this.y <= other.y\n            && this.bottomRight.x >= other.bottomRight.x\n            && this.bottomRight.y >= other.bottomRight.y;\n    }\n    intersects(other) {\n        return this.intersection(other) != null;\n    }\n    /**\n     * @return the overlap of this and [other], or null, if no such\n     *         overlap exists\n     */\n    intersection(other) {\n        const topLeft = this.topLeft.zip(other.topLeft, Math.max);\n        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.min);\n        // The intersection can't be outside of this rectangle\n        if (!this.containsPoint(topLeft) || !this.containsPoint(bottomRight)) {\n            return null;\n        }\n        else if (!other.containsPoint(topLeft) || !other.containsPoint(bottomRight)) {\n            return null;\n        }\n        return Rect2.fromCorners(topLeft, bottomRight);\n    }\n    /** @return a new rectangle containing both [this] and [other]. */\n    union(other) {\n        const topLeft = this.topLeft.zip(other.topLeft, Math.min);\n        const bottomRight = this.bottomRight.zip(other.bottomRight, Math.max);\n        return Rect2.fromCorners(topLeft, bottomRight);\n    }\n    /**\n     * @param margin The minimum distance between the new point and the edge\n     *               of the resultant rectangle.\n     * @return a new rectangle that contains this and the given point.\n     */\n    grownToPoint(point, margin = 0) {\n        const otherRect = new Rect2(point.x - margin, point.y - margin, margin * 2, margin * 2);\n        return this.union(otherRect);\n    }\n    // Returns this grown by [margin] in both the x and y directions.\n    grownBy(margin) {\n        return new Rect2(this.x - margin, this.y - margin, this.w + margin * 2, this.h + margin * 2);\n    }\n    get corners() {\n        return [\n            this.bottomRight,\n            this.topRight,\n            this.topLeft,\n            this.bottomLeft,\n        ];\n    }\n    get maxDimension() {\n        return Math.max(this.w, this.h);\n    }\n    get topRight() {\n        return this.bottomRight.plus(Vec2_1.Vec2.of(0, -this.h));\n    }\n    get bottomLeft() {\n        return this.topLeft.plus(Vec2_1.Vec2.of(0, this.h));\n    }\n    // Returns edges in the order\n    // [ rightEdge, topEdge, leftEdge, bottomEdge ]\n    getEdges() {\n        const corners = this.corners;\n        return [\n            new LineSegment2_1.default(corners[0], corners[1]),\n            new LineSegment2_1.default(corners[1], corners[2]),\n            new LineSegment2_1.default(corners[2], corners[3]),\n            new LineSegment2_1.default(corners[3], corners[0]),\n        ];\n    }\n    /**\n     * @param affineTransform A transformation matrix to be interpreted as an affine\n     *                        transformation.\n     * @return the bounding box of this' four corners after transformed by\n     *         the given affine transformation.\n     */\n    transformedBoundingBox(affineTransform) {\n        return Rect2.bboxOf(this.corners.map(corner => affineTransform.transformVec2(corner)));\n    }\n    /** @return true iff this is equal to [other] ± fuzz */\n    eq(other, fuzz = 0) {\n        return this.topLeft.eq(other.topLeft, fuzz) && this.size.eq(other.size, fuzz);\n    }\n    toString() {\n        return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))`;\n    }\n    static fromCorners(corner1, corner2) {\n        return new Rect2(Math.min(corner1.x, corner2.x), Math.min(corner1.y, corner2.y), Math.abs(corner1.x - corner2.x), Math.abs(corner1.y - corner2.y));\n    }\n    /**\n     * @return a box that contains all points in [points] with at least\n     *         [margin] between each point and the edge of the box.\n     */\n    static bboxOf(points, margin = 0) {\n        let minX = 0;\n        let minY = 0;\n        let maxX = 0;\n        let maxY = 0;\n        let isFirst = true;\n        for (const point of points) {\n            if (isFirst) {\n                minX = point.x;\n                minY = point.y;\n                maxX = point.x;\n                maxY = point.y;\n                isFirst = false;\n            }\n            minX = Math.min(minX, point.x);\n            minY = Math.min(minY, point.y);\n            maxX = Math.max(maxX, point.x);\n            maxY = Math.max(maxY, point.y);\n        }\n        return Rect2.fromCorners(Vec2_1.Vec2.of(minX - margin, minY - margin), Vec2_1.Vec2.of(maxX + margin, maxY + margin));\n    }\n    static of(template) {\n        var _a, _b, _c, _d;\n        const width = (_b = (_a = template.width) !== null && _a !== void 0 ? _a : template.w) !== null && _b !== void 0 ? _b : 0;\n        const height = (_d = (_c = template.height) !== null && _c !== void 0 ? _c : template.h) !== null && _d !== void 0 ? _d : 0;\n        return new Rect2(template.x, template.y, width, height);\n    }\n}\nexports[\"default\"] = Rect2;\nRect2.empty = new Rect2(0, 0, 0, 0);\nRect2.unitSquare = new Rect2(0, 0, 1, 1);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/geometry/Rect2.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/geometry/Vec2.ts":
/*!************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/geometry/Vec2.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Vec2 = void 0;\nconst Vec3_1 = __webpack_require__(/*! ./Vec3 */ \"./components/NoteEditor/ImageEditor/geometry/Vec3.ts\");\nvar Vec2;\n(function (Vec2) {\n    Vec2.of = (x, y) => {\n        return Vec3_1.default.of(x, y, 0);\n    };\n    Vec2.ofXY = ({ x, y }) => {\n        return Vec3_1.default.of(x, y, 0);\n    };\n    Vec2.unitX = Vec2.of(1, 0);\n    Vec2.unitY = Vec2.of(0, 1);\n    Vec2.zero = Vec2.of(0, 0);\n})(Vec2 = exports.Vec2 || (exports.Vec2 = {}));\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/geometry/Vec2.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/geometry/Vec3.ts":
/*!************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/geometry/Vec3.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// A vector with three components. Can also be used to represent a two-component vector\nclass Vec3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    // Returns the x, y components of this\n    get xy() {\n        // Useful for APIs that behave differently if .z is present.\n        return {\n            x: this.x,\n            y: this.y,\n        };\n    }\n    static of(x, y, z) {\n        return new Vec3(x, y, z);\n    }\n    /** @return the [idx]th component of this. */\n    at(idx) {\n        if (idx == 0)\n            return this.x;\n        if (idx == 1)\n            return this.y;\n        if (idx == 2)\n            return this.z;\n        throw new Error(`${idx} out of bounds!`);\n    }\n    /** @return the L2 norm of this */\n    magnitude() {\n        return Math.sqrt(this.dot(this));\n    }\n    /**\n     * @return this vector's angle in the XY plane (treats this as a Vec2).\n     *         The angle is in radians and is measured counterclockwise.\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    normalized() {\n        const norm = this.magnitude();\n        return Vec3.of(this.x / norm, this.y / norm, this.z / norm);\n    }\n    times(c) {\n        return Vec3.of(this.x * c, this.y * c, this.z * c);\n    }\n    plus(v) {\n        return Vec3.of(this.x + v.x, this.y + v.y, this.z + v.z);\n    }\n    minus(v) {\n        return this.plus(v.times(-1));\n    }\n    dot(other) {\n        return this.x * other.x + this.y * other.y + this.z * other.z;\n    }\n    cross(other) {\n        // | i  j  k |\n        // | x1 y1 z1| = (i)(y1z2 - y2z1) - (j)(x1z2 - x2z1) + (k)(x1y2 - x2y1)\n        // | x2 y2 z2|\n        return Vec3.of(this.y * other.z - other.y * this.z, other.x * this.z - this.x * other.z, this.x * other.y - other.x * this.y);\n    }\n    /** @return this + direction.normalized() * distance */\n    extend(distance, direction) {\n        return this.plus(direction.normalized().times(distance));\n    }\n    /** @return a vector [fractionTo] of the way to target from this. */\n    lerp(target, fractionTo) {\n        return this.times(1 - fractionTo).plus(target.times(fractionTo));\n    }\n    /**\n     * @param zip Maps a component of this and a corresponding component of\n     *            [other] to a component of the output vector.\n     */\n    zip(other, zip) {\n        return Vec3.of(zip(other.x, this.x), zip(other.y, this.y), zip(other.z, this.z));\n    }\n    /**\n     * @return each component of this mapped to a new component by [fn]\n     */\n    map(fn) {\n        return Vec3.of(fn(this.x), fn(this.y), fn(this.z));\n    }\n    asArray() {\n        return [this.x, this.y, this.z];\n    }\n    /**\n     * @return true iff each component of this is equal to the corresponding\n     * \t\t\t\tcomponent of [other]\n     */\n    eq(other, fuzz) {\n        for (let i = 0; i < 3; i++) {\n            if (Math.abs(other.at(i) - this.at(i)) > fuzz) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        return `Vec(${this.x}, ${this.y}, ${this.z})`;\n    }\n}\nexports[\"default\"] = Vec3;\nVec3.unitX = Vec3.of(1, 0, 0);\nVec3.unitY = Vec3.of(0, 1, 0);\nVec3.unitZ = Vec3.of(0, 0, 1);\nVec3.zero = Vec3.of(0, 0, 0);\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/geometry/Vec3.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/rendering/AbstractRenderer.ts":
/*!*************************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/rendering/AbstractRenderer.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Mat33_1 = __webpack_require__(/*! ../geometry/Mat33 */ \"./components/NoteEditor/ImageEditor/geometry/Mat33.ts\");\nconst Path_1 = __webpack_require__(/*! ../geometry/Path */ \"./components/NoteEditor/ImageEditor/geometry/Path.ts\");\nconst Rect2_1 = __webpack_require__(/*! ../geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nclass AbstractRenderer {\n    constructor(viewport) {\n        this.viewport = viewport;\n    }\n    drawPath({ startPoint, commands, style: fill }, transform = Mat33_1.default.identity) {\n        this.beginPath(transform.transformVec2(startPoint));\n        for (const command of commands) {\n            if (command.kind === Path_1.PathCommandType.LineTo) {\n                this.lineTo(transform.transformVec2(command.point));\n            }\n            else if (command.kind === Path_1.PathCommandType.CubicBezierTo) {\n                this.traceCubicBezierCurve(transform.transformVec2(command.controlPoint1), transform.transformVec2(command.controlPoint2), transform.transformVec2(command.endPoint));\n            }\n            else if (command.kind === Path_1.PathCommandType.QuadraticBezierTo) {\n                this.traceQuadraticBezierCurve(transform.transformVec2(command.controlPoint), transform.transformVec2(command.endPoint));\n            }\n        }\n        this.endPath(fill);\n    }\n    // Draw a rectangle. Boundary lines have width [lineWidth] and are filled with [lineFill]\n    drawRect(rect, lineWidth, lineFill) {\n        const commands = [];\n        // Vector from the top left corner or bottom right corner to the edge of the\n        // stroked region.\n        const cornerToEdge = Vec2_1.Vec2.of(lineWidth, lineWidth).times(0.5);\n        const innerRect = Rect2_1.default.fromCorners(rect.topLeft.plus(cornerToEdge), rect.bottomRight.minus(cornerToEdge));\n        const outerRect = Rect2_1.default.fromCorners(rect.topLeft.minus(cornerToEdge), rect.bottomRight.plus(cornerToEdge));\n        const corners = [\n            innerRect.corners[3],\n            ...innerRect.corners,\n            ...outerRect.corners.reverse(),\n        ];\n        for (const corner of corners) {\n            commands.push({\n                kind: Path_1.PathCommandType.LineTo,\n                point: corner,\n            });\n        }\n        this.drawPath({\n            startPoint: outerRect.corners[3],\n            commands,\n            style: lineFill,\n        });\n    }\n}\nexports[\"default\"] = AbstractRenderer;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/rendering/AbstractRenderer.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/rendering/CanvasRenderer.ts":
/*!***********************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/rendering/CanvasRenderer.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Color4_1 = __webpack_require__(/*! ../Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ \"./components/NoteEditor/ImageEditor/rendering/AbstractRenderer.ts\");\nconst minCurveApproxDist = 5;\nclass CanvasRenderer extends AbstractRenderer_1.default {\n    constructor(ctx, viewport) {\n        super(viewport);\n        this.ctx = ctx;\n    }\n    displaySize() {\n        return Vec2_1.Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight);\n    }\n    clear() {\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    }\n    beginPath(startPoint) {\n        startPoint = this.viewport.canvasToScreen(startPoint);\n        this.ctx.beginPath();\n        this.ctx.moveTo(startPoint.x, startPoint.y);\n    }\n    endPath(style) {\n        this.ctx.fillStyle = style.fill.toHexString();\n        this.ctx.fill();\n        if (style.stroke) {\n            this.ctx.strokeStyle = style.stroke.color.toHexString();\n            this.ctx.lineWidth = this.viewport.getScaleFactor() * style.stroke.width;\n            this.ctx.stroke();\n        }\n        this.ctx.closePath();\n    }\n    lineTo(point) {\n        point = this.viewport.canvasToScreen(point);\n        this.ctx.lineTo(point.x, point.y);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        p1 = this.viewport.canvasToScreen(p1);\n        p2 = this.viewport.canvasToScreen(p2);\n        p3 = this.viewport.canvasToScreen(p3);\n        // Approximate the curve if small enough.\n        const delta1 = p2.minus(p1);\n        const delta2 = p3.minus(p2);\n        if (delta1.dot(delta1) < minCurveApproxDist * minCurveApproxDist\n            && delta2.dot(delta2) < minCurveApproxDist * minCurveApproxDist) {\n            this.ctx.lineTo(p3.x, p3.y);\n        }\n        else {\n            this.ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);\n        }\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.viewport.canvasToScreen(controlPoint);\n        endPoint = this.viewport.canvasToScreen(endPoint);\n        // Approximate the curve with a line if small enough\n        const delta = controlPoint.minus(endPoint);\n        if (delta.dot(delta) < minCurveApproxDist * minCurveApproxDist) {\n            this.ctx.lineTo(endPoint.x, endPoint.y);\n        }\n        else {\n            this.ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, endPoint.x, endPoint.y);\n        }\n    }\n    drawPoints(...points) {\n        const pointRadius = 10;\n        for (let i = 0; i < points.length; i++) {\n            const point = this.viewport.canvasToScreen(points[i]);\n            this.ctx.beginPath();\n            this.ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);\n            this.ctx.fillStyle = Color4_1.default.ofRGBA(0.5 + Math.sin(i) / 2, 1.0, 0.5 + Math.cos(i * 0.2) / 4, 0.5).toHexString();\n            this.ctx.fill();\n            this.ctx.stroke();\n            this.ctx.closePath();\n            this.ctx.textAlign = 'center';\n            this.ctx.textBaseline = 'middle';\n            this.ctx.fillStyle = 'black';\n            this.ctx.fillText(`${i}`, point.x, point.y, pointRadius * 2);\n        }\n    }\n    startObject(_boundingBox) {\n        // Do nothing. TODO: Use this to optimize drawing (e.g. skip drawing if the box is\n        // small enough).\n    }\n    endObject() {\n        // Do nothing\n    }\n}\nexports[\"default\"] = CanvasRenderer;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/rendering/CanvasRenderer.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/rendering/DummyRenderer.ts":
/*!**********************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/rendering/DummyRenderer.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n// Renderer that outputs nothing. Useful for automated tests.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ \"./components/NoteEditor/ImageEditor/rendering/AbstractRenderer.ts\");\nclass DummyRenderer extends AbstractRenderer_1.default {\n    constructor(viewport) {\n        super(viewport);\n        // Variables that track the state of what's been rendered\n        this.clearedCount = 0;\n        this.renderedPathCount = 0;\n        this.lastFillStyle = null;\n        this.lastPoint = null;\n        this.objectNestingLevel = 0;\n        // List of points drawn since the last clear.\n        this.pointBuffer = [];\n    }\n    displaySize() {\n        // Return a dummy\n        return Vec2_1.Vec2.of(640, 480);\n    }\n    clear() {\n        this.clearedCount++;\n        this.renderedPathCount = 0;\n        this.pointBuffer = [];\n        // Ensure all objects finished rendering\n        if (this.objectNestingLevel > 0) {\n            throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`);\n        }\n    }\n    beginPath(startPoint) {\n        this.lastPoint = startPoint;\n        this.pointBuffer.push(startPoint);\n    }\n    endPath(style) {\n        this.renderedPathCount++;\n        this.lastFillStyle = style;\n    }\n    lineTo(point) {\n        this.lastPoint = point;\n        this.pointBuffer.push(point);\n    }\n    traceCubicBezierCurve(p1, p2, p3) {\n        this.lastPoint = p3;\n        this.pointBuffer.push(p1, p2, p3);\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        this.lastPoint = endPoint;\n        this.pointBuffer.push(controlPoint, endPoint);\n    }\n    drawPoints(..._points) {\n        // drawPoints is intended for debugging.\n        // As such, it is unlikely to be the target of automated tests.\n    }\n    startObject(_boundingBox) {\n        // Ignore the start/end of different objects\n        this.objectNestingLevel += 1;\n    }\n    endObject() {\n        this.objectNestingLevel -= 1;\n    }\n}\nexports[\"default\"] = DummyRenderer;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/rendering/DummyRenderer.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/rendering/SVGRenderer.ts":
/*!********************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/rendering/SVGRenderer.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Path_1 = __webpack_require__(/*! ../geometry/Path */ \"./components/NoteEditor/ImageEditor/geometry/Path.ts\");\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ \"./components/NoteEditor/ImageEditor/rendering/AbstractRenderer.ts\");\nconst svgNameSpace = 'http://www.w3.org/2000/svg';\nclass SVGRenderer extends AbstractRenderer_1.default {\n    constructor(elem, viewport) {\n        super(viewport);\n        this.elem = elem;\n        this.clear();\n    }\n    displaySize() {\n        return Vec2_1.Vec2.of(this.elem.clientWidth, this.elem.clientHeight);\n    }\n    clear() {\n        this.mainGroup = document.createElementNS(svgNameSpace, 'g');\n        // Remove all children\n        this.elem.replaceChildren(this.mainGroup);\n    }\n    beginPath(startPoint) {\n        var _a;\n        this.currentPath = [];\n        this.pathStart = this.viewport.canvasToScreen(startPoint);\n        (_a = this.lastPathStart) !== null && _a !== void 0 ? _a : (this.lastPathStart = this.pathStart);\n    }\n    endPath(style) {\n        var _a;\n        // Try to extend the previous path, if possible\n        if (style.fill.eq((_a = this.lastPathStyle) === null || _a === void 0 ? void 0 : _a.fill)) {\n            this.lastPath.push({\n                kind: Path_1.PathCommandType.MoveTo,\n                point: this.pathStart,\n            }, ...this.currentPath);\n            this.pathStart = null;\n            this.currentPath = null;\n        }\n        else {\n            this.addPathToSVG();\n            this.lastPathStart = this.pathStart;\n            this.lastPathStyle = style;\n            this.lastPath = this.currentPath;\n            this.pathStart = null;\n            this.currentPath = null;\n        }\n    }\n    // Push [this.fullPath] to the SVG\n    addPathToSVG() {\n        if (!this.lastPathStyle || !this.lastPath) {\n            return;\n        }\n        const pathElem = document.createElementNS(svgNameSpace, 'path');\n        pathElem.setAttribute('d', Path_1.default.toString(this.lastPathStart, this.lastPath));\n        const style = this.lastPathStyle;\n        pathElem.setAttribute('fill', style.fill.toHexString());\n        if (this.lastPathStyle.stroke) {\n            pathElem.setAttribute('stroke', style.stroke.color.toHexString());\n            pathElem.setAttribute('stroke-width', style.stroke.width.toString());\n        }\n        this.mainGroup.appendChild(pathElem);\n    }\n    startObject(_boundingBox) {\n        // Only accumulate a path within an object\n        this.lastPath = null;\n        this.lastPathStart = null;\n        this.lastPathStyle = null;\n    }\n    endObject() {\n        // Don't extend paths across objects\n        this.addPathToSVG();\n    }\n    lineTo(point) {\n        point = this.viewport.canvasToScreen(point);\n        this.currentPath.push({\n            kind: Path_1.PathCommandType.LineTo,\n            point,\n        });\n    }\n    traceCubicBezierCurve(controlPoint1, controlPoint2, endPoint) {\n        controlPoint1 = this.viewport.canvasToScreen(controlPoint1);\n        controlPoint2 = this.viewport.canvasToScreen(controlPoint2);\n        endPoint = this.viewport.canvasToScreen(endPoint);\n        this.currentPath.push({\n            kind: Path_1.PathCommandType.CubicBezierTo,\n            controlPoint1,\n            controlPoint2,\n            endPoint,\n        });\n    }\n    traceQuadraticBezierCurve(controlPoint, endPoint) {\n        controlPoint = this.viewport.canvasToScreen(controlPoint);\n        endPoint = this.viewport.canvasToScreen(endPoint);\n        this.currentPath.push({\n            kind: Path_1.PathCommandType.QuadraticBezierTo,\n            controlPoint,\n            endPoint,\n        });\n    }\n    drawPoints(...points) {\n        points.map(point => {\n            const elem = document.createElementNS(svgNameSpace, 'circle');\n            elem.setAttribute('cx', `${point.x}`);\n            elem.setAttribute('cy', `${point.y}`);\n            elem.setAttribute('r', '15');\n            this.mainGroup.appendChild(elem);\n        });\n    }\n    // Renders a copy of the given element.\n    drawSVGElem(elem) {\n        this.elem.appendChild(elem.cloneNode(true));\n    }\n}\nexports[\"default\"] = SVGRenderer;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/rendering/SVGRenderer.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/toolbar/HTMLToolbar.ts":
/*!******************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/toolbar/HTMLToolbar.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ToolController_1 = __webpack_require__(/*! ../tools/ToolController */ \"./components/NoteEditor/ImageEditor/tools/ToolController.ts\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./components/NoteEditor/ImageEditor/types.ts\");\n__webpack_require__(/*! ./toolbar.css */ \"./components/NoteEditor/ImageEditor/toolbar/toolbar.css\");\n__webpack_require__(/*! @melloware/coloris/dist/coloris.css */ \"./node_modules/@melloware/coloris/dist/coloris.css\");\nconst coloris_1 = __webpack_require__(/*! @melloware/coloris */ \"./node_modules/@melloware/coloris/dist/umd/coloris.js\");\nconst Color4_1 = __webpack_require__(/*! ../Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nconst Pen_1 = __webpack_require__(/*! ../tools/Pen */ \"./components/NoteEditor/ImageEditor/tools/Pen.ts\");\nconst Eraser_1 = __webpack_require__(/*! ../tools/Eraser */ \"./components/NoteEditor/ImageEditor/tools/Eraser.ts\");\nconst SelectionTool_1 = __webpack_require__(/*! ../tools/SelectionTool */ \"./components/NoteEditor/ImageEditor/tools/SelectionTool.ts\");\n// WidgetBuilder\n//  → build()\n//  → withIcon(...)\n//  → withTitle(...)\nconst toolbarCSSPrefix = 'toolbar-';\nclass ToolbarWidget {\n    constructor(editor, targetTool) {\n        this.targetTool = targetTool;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${toolbarCSSPrefix}toolContainer`);\n        this.dropdownContainer = document.createElement('div');\n        this.dropdownContainer.classList.add(`${toolbarCSSPrefix}dropdown`);\n        this.dropdownContainer.classList.add('hidden');\n        this.button = document.createElement('div');\n        this.button.classList.add(`${toolbarCSSPrefix}button`);\n        this.label = document.createElement('label');\n        this.button.setAttribute('role', 'button');\n        this.button.tabIndex = 0;\n        this.button.onclick = () => {\n            this.handleClick();\n        };\n        editor.notifier.on(types_1.EditorEventType.ToolEnabled, toolEvt => {\n            if (toolEvt.kind !== types_1.EditorEventType.ToolEnabled) {\n                throw new Error('Incorrect event type! (Expected ToolEnabled)');\n            }\n            if (toolEvt.tool === targetTool) {\n                this.updateSelected(true);\n            }\n        });\n        editor.notifier.on(types_1.EditorEventType.ToolDisabled, toolEvt => {\n            if (toolEvt.kind !== types_1.EditorEventType.ToolDisabled) {\n                throw new Error('Incorrect event type! (Expected ToolDisabled)');\n            }\n            if (toolEvt.tool === targetTool) {\n                this.updateSelected(false);\n                this.setDropdownVisible(false);\n            }\n        });\n    }\n    handleClick() {\n        this.targetTool.setEnabled(!this.targetTool.isEnabled());\n    }\n    // Adds this to [parent]. This can only be called once for each ToolbarWidget.\n    addTo(parent) {\n        this.label.innerText = this.getTitle();\n        this.icon = null;\n        this.updateIcon();\n        this.updateSelected(this.targetTool.isEnabled());\n        this.button.replaceChildren(this.icon, this.label);\n        this.container.appendChild(this.button);\n        if (this.fillDropdown(this.dropdownContainer)) {\n            this.dropdownIcon = this.createDropdownIcon();\n            this.button.appendChild(this.dropdownIcon);\n            this.container.appendChild(this.dropdownContainer);\n        }\n        this.setDropdownVisible(false);\n        parent.appendChild(this.container);\n    }\n    updateIcon() {\n        var _a;\n        const newIcon = this.createIcon();\n        (_a = this.icon) === null || _a === void 0 ? void 0 : _a.replaceWith(newIcon);\n        this.icon = newIcon;\n        this.icon.classList.add(`${toolbarCSSPrefix}icon`);\n    }\n    updateSelected(active) {\n        if (active) {\n            this.container.classList.add('selected');\n        }\n        else {\n            this.container.classList.remove('selected');\n        }\n    }\n    setDropdownVisible(visible) {\n        if (visible) {\n            this.dropdownContainer.classList.remove('hidden');\n            this.container.classList.add('dropdownVisible');\n        }\n        else {\n            this.dropdownContainer.classList.add('hidden');\n            this.container.classList.remove('dropdownVisible');\n        }\n    }\n    isDropdownVisible() {\n        return !this.dropdownContainer.classList.contains('hidden');\n    }\n    createDropdownIcon() {\n        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<path d='M5,10 L50,90 L95,10 Z'/>\n\t\t</g>\n\t\t`;\n        icon.classList.add(`${toolbarCSSPrefix}showHideDropdownIcon`);\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n}\nclass EraserWidget extends ToolbarWidget {\n    getTitle() {\n        return 'Eraser'; // TODO: Localize\n    }\n    createIcon() {\n        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        // Draw an eraser-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<rect x=10 y=50 width=80 height=30 rx=10 fill='pink' />\n\t\t\t<rect x=10 y=10 width=80 height=50 fill='black'/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    fillDropdown(_dropdown) {\n        // No dropdown associated with the eraser\n        return false;\n    }\n}\nclass SelectionWidget extends ToolbarWidget {\n    getTitle() {\n        return 'Select'; // TODO: Localize\n    }\n    createIcon() {\n        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        // Draw a cursor-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<rect x=10 y=10 width=70 height=70 fill='pink' stroke='black'/>\n\t\t\t<rect x=75 y=75 width=10 height=10 fill='white' stroke='black'/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    fillDropdown(_dropdown) {\n        // No dropdown\n        return false;\n    }\n}\nclass TouchDrawingWidget extends ToolbarWidget {\n    getTitle() {\n        return 'Touch Drawing'; // TODO: Localize\n    }\n    createIcon() {\n        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        // Draw a cursor-like shape\n        icon.innerHTML = `\n\t\t<g>\n\t\t\t<path d='M11,-30 Q0,10 20,20 Q40,20 40,-30 Z' fill='blue'/>\n\t\t\t<path d='\n\t\t\t\tM0,90 L0,50 Q5,40 10,50\n\t\t\t\tL10,20 Q20,15 30,20\n\t\t\t\tL30,50 Q50,40 80,50\n\t\t\t\tL80,90 L10,90 Z' fill='black' stroke='black' />\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '-10 -30 100 100');\n        return icon;\n    }\n    fillDropdown(_dropdown) {\n        // No dropdown\n        return false;\n    }\n    updateSelected(active) {\n        if (active) {\n            this.container.classList.remove('selected');\n        }\n        else {\n            this.container.classList.add('selected');\n        }\n    }\n}\nclass PenWidget extends ToolbarWidget {\n    constructor(editor, tool) {\n        super(editor, tool);\n        this.editor = editor;\n        this.tool = tool;\n        this.updateInputs = () => { };\n        this.editor.notifier.on(types_1.EditorEventType.ToolUpdated, toolEvt => {\n            if (toolEvt.kind !== types_1.EditorEventType.ToolUpdated) {\n                throw new Error('Invalid event type!');\n            }\n            // The button icon may depend on tool properties.\n            if (toolEvt.tool === this.tool) {\n                this.updateIcon();\n                this.updateInputs();\n            }\n        });\n    }\n    getTitle() {\n        return 'Pen'; // TODO: Localize\n    }\n    createIcon() {\n        // We need to use createElementNS to embed an SVG element in HTML.\n        // See http://zhangwenli.com/blog/2017/07/26/createelementns/\n        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        // Use a square-root scale to prevent the pen's tip from overflowing.\n        const scale = Math.round(Math.sqrt(this.tool.getThickness()) * 2);\n        const color = this.tool.getColor();\n        // Draw a pen-like shape\n        const primaryStrokeTipPath = `M14,63 L${50 - scale},95 L${50 + scale},90 L88,60 Z`;\n        const backgroundStrokeTipPath = `M14,63 L${50 - scale},85 L${50 + scale},83 L88,60 Z`;\n        icon.innerHTML = `\n\t\t<defs>\n\t\t\t<pattern\n\t\t\t\tid='checkerboard'\n\t\t\t\tviewBox='0,0,10,10'\n\t\t\t\twidth='20%'\n\t\t\t\theight='20%'\n\t\t\t\tpatternUnits='userSpaceOnUse'\n\t\t\t>\n\t\t\t\t<rect x=0 y=0 width=10 height=10 fill='white'/>\n\t\t\t\t<rect x=0 y=0 width=5 height=5 fill='gray'/>\n\t\t\t\t<rect x=5 y=5 width=5 height=5 fill='gray'/>\n\t\t\t</pattern>\n\t\t</defs>\n\t\t<g>\n\t\t\t<!-- Pen grip -->\n\t\t\t<path\n\t\t\t\td='M10,10 L90,10 L90,60 L${50 + scale},80 L${50 - scale},80 L10,60 Z'\n\t\t\t\tfill='black' stroke='black'/>\n\t\t</g>\n\t\t<g>\n\t\t\t<!-- Checkerboard background for slightly transparent pens -->\n\t\t\t<path d='${backgroundStrokeTipPath}' fill='url(#checkerboard)'/>\n\n\t\t\t<!-- Actual pen tip -->\n\t\t\t<path\n\t\t\t\td='${primaryStrokeTipPath}'\n\t\t\t\tfill='${color.toHexString()}'\n\t\t\t\tstroke='${color.toHexString()}'\n\t\t\t/>\n\t\t</g>\n\t\t`;\n        icon.setAttribute('viewBox', '0 0 100 100');\n        return icon;\n    }\n    fillDropdown(dropdown) {\n        const container = document.createElement('div');\n        // Thickness: Value of the input is squared to allow for finer control/larger values.\n        const thicknessRow = document.createElement('div');\n        const thicknessLabel = document.createElement('label');\n        const thicknessInput = document.createElement('input');\n        thicknessInput.id = `${toolbarCSSPrefix}thicknessInput${PenWidget.idCounter++}`;\n        thicknessLabel.innerText = 'Thickness: '; // TODO: Localize\n        thicknessLabel.setAttribute('for', thicknessInput.id);\n        thicknessInput.type = 'range';\n        thicknessInput.min = '1';\n        thicknessInput.max = '20';\n        thicknessInput.step = '1';\n        thicknessInput.oninput = () => {\n            this.tool.setThickness(Math.pow(parseFloat(thicknessInput.value), 2));\n        };\n        thicknessRow.appendChild(thicknessLabel);\n        thicknessRow.appendChild(thicknessInput);\n        const colorRow = document.createElement('div');\n        const colorLabel = document.createElement('label');\n        const colorInput = document.createElement('input');\n        colorInput.id = `${toolbarCSSPrefix}colorInput${PenWidget.idCounter++}`;\n        colorLabel.innerText = 'Color: ';\n        colorLabel.setAttribute('for', colorInput.id);\n        colorInput.className = 'coloris_input';\n        colorInput.type = 'button';\n        colorInput.oninput = () => {\n            this.tool.setColor(Color4_1.default.fromHex(colorInput.value));\n        };\n        colorRow.appendChild(colorLabel);\n        colorRow.appendChild(colorInput);\n        this.updateInputs = () => {\n            colorInput.value = this.tool.getColor().toHexString();\n            thicknessInput.value = Math.sqrt(this.tool.getThickness()).toString();\n        };\n        this.updateInputs();\n        container.replaceChildren(colorRow, thicknessRow);\n        dropdown.replaceChildren(container);\n        return true;\n    }\n    handleClick() {\n        if (!this.tool.isEnabled()) {\n            this.tool.setEnabled(true);\n        }\n        else {\n            this.setDropdownVisible(!this.isDropdownVisible());\n        }\n    }\n}\nPenWidget.idCounter = 0;\n/**\n * An HTML implementation of the toolbar. This implementation is primarially intended for\n * debugging purposes — when the editor is running directly in a browser.\n */\nclass HTMLToolbar {\n    constructor(editor, parent) {\n        this.editor = editor;\n        this.container = document.createElement('div');\n        this.container.classList.add(`${toolbarCSSPrefix}root`);\n        this.addElements();\n        parent.appendChild(this.container);\n        // Initialize color choosers\n        (0, coloris_1.init)();\n        (0, coloris_1.coloris)({\n            el: '.coloris_input',\n            format: 'hex',\n            theme: 'polaroid',\n            selectInput: false,\n            focusInput: false,\n            swatches: [\n                Color4_1.default.red.toHexString(),\n                Color4_1.default.purple.toHexString(),\n                Color4_1.default.blue.toHexString(),\n                Color4_1.default.yellow.toHexString(),\n                Color4_1.default.green.toHexString(),\n                Color4_1.default.clay.toHexString(),\n                Color4_1.default.black.toHexString(),\n                Color4_1.default.white.toHexString(),\n            ],\n        });\n    }\n    addActionButton(text, command) {\n        const button = document.createElement('button');\n        button.innerText = text;\n        button.classList.add('toolButton');\n        button.onclick = command;\n        this.container.appendChild(button);\n    }\n    addElements() {\n        const toolController = this.editor.toolController;\n        for (const tool of toolController.getMatchingTools(ToolController_1.ToolType.Pen)) {\n            if (!(tool instanceof Pen_1.default)) {\n                throw new Error('All `Pen` tools must have kind === ToolType.Pen');\n            }\n            const widget = new PenWidget(this.editor, tool);\n            widget.addTo(this.container);\n        }\n        for (const tool of toolController.getMatchingTools(ToolController_1.ToolType.Eraser)) {\n            if (!(tool instanceof Eraser_1.default)) {\n                throw new Error('All Erasers must have kind === ToolType.Eraser!');\n            }\n            (new EraserWidget(this.editor, tool)).addTo(this.container);\n        }\n        for (const tool of toolController.getMatchingTools(ToolController_1.ToolType.Selection)) {\n            if (!(tool instanceof SelectionTool_1.default)) {\n                throw new Error('All SelectionTools must have kind === ToolType.Selection');\n            }\n            (new SelectionWidget(this.editor, tool)).addTo(this.container);\n        }\n        for (const tool of toolController.getMatchingTools(ToolController_1.ToolType.TouchPanZoom)) {\n            (new TouchDrawingWidget(this.editor, tool)).addTo(this.container);\n        }\n        this.addActionButton('Undo', () => {\n            this.editor.history.undo();\n        });\n        this.addActionButton('Redo', () => {\n            this.editor.history.redo();\n        });\n    }\n}\nexports[\"default\"] = HTMLToolbar;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/toolbar/HTMLToolbar.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/BaseTool.ts":
/*!*************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/BaseTool.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ../types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nclass BaseTool {\n    constructor(notifier) {\n        this.notifier = notifier;\n        this.enabled = true;\n        this.group = null;\n    }\n    onWheel(_event) {\n        return false;\n    }\n    onKeyPress(_event) {\n        return false;\n    }\n    setEnabled(enabled) {\n        var _a;\n        this.enabled = enabled;\n        // Ensure that at most one tool in the group is enabled.\n        if (enabled) {\n            (_a = this.group) === null || _a === void 0 ? void 0 : _a.notifyEnabled(this);\n            this.notifier.dispatch(types_1.EditorEventType.ToolEnabled, {\n                kind: types_1.EditorEventType.ToolEnabled,\n                tool: this,\n            });\n        }\n        else {\n            this.notifier.dispatch(types_1.EditorEventType.ToolDisabled, {\n                kind: types_1.EditorEventType.ToolDisabled,\n                tool: this,\n            });\n        }\n    }\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Connect this tool to a set of other tools, ensuring that at most one\n     * of the tools in the group is enabled.\n     */\n    setToolGroup(group) {\n        if (this.isEnabled()) {\n            group.notifyEnabled(this);\n        }\n        this.group = group;\n    }\n}\nexports[\"default\"] = BaseTool;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/BaseTool.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/Eraser.ts":
/*!***********************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/Eraser.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BaseTool_1 = __webpack_require__(/*! ./BaseTool */ \"./components/NoteEditor/ImageEditor/tools/BaseTool.ts\");\nconst LineSegment2_1 = __webpack_require__(/*! ../geometry/LineSegment2 */ \"./components/NoteEditor/ImageEditor/geometry/LineSegment2.ts\");\nconst Erase_1 = __webpack_require__(/*! ../commands/Erase */ \"./components/NoteEditor/ImageEditor/commands/Erase.ts\");\nconst ToolController_1 = __webpack_require__(/*! ./ToolController */ \"./components/NoteEditor/ImageEditor/tools/ToolController.ts\");\nclass Eraser extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier);\n        this.editor = editor;\n        this.kind = ToolController_1.ToolType.Eraser;\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1) {\n            this.lastPoint = event.current.canvasPos;\n            this.toRemove = [];\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        var _a;\n        const currentPoint = event.current.canvasPos;\n        if (currentPoint.minus(this.lastPoint).magnitude() === 0) {\n            return;\n        }\n        const line = new LineSegment2_1.default(this.lastPoint, currentPoint);\n        const region = line.bbox;\n        // Remove any intersecting elements.\n        this.toRemove.push(...this.editor.image\n            .getElementsIntersectingRegion(region).filter(component => {\n            return component.intersects(line);\n        }));\n        (_a = this.command) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.command = new Erase_1.default(this.toRemove);\n        this.command.apply(this.editor);\n        this.lastPoint = currentPoint;\n    }\n    onPointerUp(_event) {\n        var _a;\n        if (this.command && this.toRemove.length > 0) {\n            (_a = this.command) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n            // Dispatch the command to make it undo-able\n            this.editor.dispatch(this.command);\n        }\n        this.command = null;\n    }\n    onGestureCancel() {\n        var _a;\n        (_a = this.command) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.command = null;\n    }\n}\nexports[\"default\"] = Eraser;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/Eraser.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/PanZoom.ts":
/*!************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/PanZoom.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PanZoomMode = void 0;\nconst Mat33_1 = __webpack_require__(/*! ../geometry/Mat33 */ \"./components/NoteEditor/ImageEditor/geometry/Mat33.ts\");\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst Vec3_1 = __webpack_require__(/*! ../geometry/Vec3 */ \"./components/NoteEditor/ImageEditor/geometry/Vec3.ts\");\nconst Pointer_1 = __webpack_require__(/*! ../Pointer */ \"./components/NoteEditor/ImageEditor/Pointer.ts\");\nconst Viewport_1 = __webpack_require__(/*! ../Viewport */ \"./components/NoteEditor/ImageEditor/Viewport.ts\");\nconst BaseTool_1 = __webpack_require__(/*! ./BaseTool */ \"./components/NoteEditor/ImageEditor/tools/BaseTool.ts\");\nconst ToolController_1 = __webpack_require__(/*! ./ToolController */ \"./components/NoteEditor/ImageEditor/tools/ToolController.ts\");\nvar PanZoomMode;\n(function (PanZoomMode) {\n    /**\n     * Handle one-pointer gestures (touchscreen only unless AnyDevice is set)\n     * @see AnyDevice\n     */\n    PanZoomMode[PanZoomMode[\"OneFingerGestures\"] = 1] = \"OneFingerGestures\";\n    /**\n     * Handle two-pointer gestures (touchscreen only unless AnyDevice is set)\n     * @see AnyDevice\n     */\n    PanZoomMode[PanZoomMode[\"TwoFingerGestures\"] = 2] = \"TwoFingerGestures\";\n    /** Handle gestures from any device, rather than just touch */\n    PanZoomMode[PanZoomMode[\"AnyDevice\"] = 4] = \"AnyDevice\";\n})(PanZoomMode = exports.PanZoomMode || (exports.PanZoomMode = {}));\nclass PanZoom extends BaseTool_1.default {\n    constructor(editor, mode) {\n        super(editor.notifier);\n        this.editor = editor;\n        this.mode = mode;\n        this.kind = ToolController_1.ToolType.PanZoom;\n        if (mode === PanZoomMode.OneFingerGestures) {\n            this.kind = ToolController_1.ToolType.TouchPanZoom;\n        }\n    }\n    /** @return information about the pointers in a gesture */\n    computePinchData(p1, p2) {\n        const screenBetween = p2.screenPos.minus(p1.screenPos);\n        const angle = screenBetween.angle();\n        const dist = screenBetween.magnitude();\n        const canvasCenter = p2.canvasPos.plus(p1.canvasPos).times(0.5);\n        const screenCenter = p2.screenPos.plus(p1.screenPos).times(0.5);\n        return { canvasCenter, screenCenter, angle, dist };\n    }\n    pointersHaveCorrectDeviceType(pointers) {\n        return this.mode & PanZoomMode.AnyDevice || pointers.every(pointer => pointer.device === Pointer_1.PointerDevice.Touch);\n    }\n    onPointerDown({ allPointers }) {\n        var _a;\n        let handlingGesture;\n        if (!this.pointersHaveCorrectDeviceType(allPointers)) {\n            handlingGesture = false;\n        }\n        else if (allPointers.length === 2 && this.mode & PanZoomMode.TwoFingerGestures) {\n            const { screenCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);\n            this.lastAngle = angle;\n            this.lastDist = dist;\n            this.lastScreenCenter = screenCenter;\n            handlingGesture = true;\n        }\n        else if (allPointers.length === 1 && this.mode & PanZoomMode.OneFingerGestures) {\n            this.lastScreenCenter = allPointers[0].screenPos;\n            handlingGesture = true;\n        }\n        if (handlingGesture) {\n            (_a = this.transform) !== null && _a !== void 0 ? _a : (this.transform = new Viewport_1.Viewport.ViewportTransform(Mat33_1.default.identity));\n        }\n        return handlingGesture;\n    }\n    // Returns the change in position of the center of the given group of pointers.\n    // Assumes this.lastScreenCenter has been set appropriately.\n    getCenterDelta(screenCenter) {\n        // Use transformVec3 to avoid translating the delta\n        const delta = this.editor.viewport.screenToCanvasTransform.transformVec3(screenCenter.minus(this.lastScreenCenter));\n        return delta;\n    }\n    handleTwoFingerMove(allPointers) {\n        const { screenCenter, canvasCenter, angle, dist } = this.computePinchData(allPointers[0], allPointers[1]);\n        const delta = this.getCenterDelta(screenCenter);\n        const transformUpdate = Mat33_1.default.translation(delta)\n            .rightMul(Mat33_1.default.scaling2D(dist / this.lastDist, canvasCenter))\n            .rightMul(Mat33_1.default.zRotation(angle - this.lastAngle, canvasCenter));\n        this.lastScreenCenter = screenCenter;\n        this.lastDist = dist;\n        this.lastAngle = angle;\n        this.transform = new Viewport_1.Viewport.ViewportTransform(this.transform.transform.rightMul(transformUpdate));\n    }\n    handleOneFingerMove(pointer) {\n        const delta = this.getCenterDelta(pointer.screenPos);\n        this.transform = new Viewport_1.Viewport.ViewportTransform(this.transform.transform.rightMul(Mat33_1.default.translation(delta)));\n        this.lastScreenCenter = pointer.screenPos;\n    }\n    onPointerMove({ allPointers }) {\n        var _a;\n        (_a = this.transform) !== null && _a !== void 0 ? _a : (this.transform = new Viewport_1.Viewport.ViewportTransform(Mat33_1.default.identity));\n        const lastTransform = this.transform;\n        if (allPointers.length === 2 && this.mode & PanZoomMode.TwoFingerGestures) {\n            this.handleTwoFingerMove(allPointers);\n        }\n        else if (allPointers.length === 1 && this.mode & PanZoomMode.OneFingerGestures) {\n            this.handleOneFingerMove(allPointers[0]);\n        }\n        lastTransform.unapply(this.editor);\n        this.transform.apply(this.editor);\n    }\n    onPointerUp(_event) {\n        this.transform = null;\n    }\n    onGestureCancel() {\n        var _a;\n        (_a = this.transform) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.transform = null;\n    }\n    // Applies [transformUpdate] to the editor. This stacks on top of the\n    // current transformation, if it exists.\n    updateTransform(transformUpdate) {\n        var _a;\n        let newTransform = transformUpdate;\n        if (this.transform) {\n            newTransform = this.transform.transform.rightMul(transformUpdate);\n        }\n        (_a = this.transform) === null || _a === void 0 ? void 0 : _a.unapply(this.editor);\n        this.transform = new Viewport_1.Viewport.ViewportTransform(newTransform);\n        this.transform.apply(this.editor);\n    }\n    onWheel({ delta, screenPos }) {\n        if (this.transform == null) {\n            this.transform = new Viewport_1.Viewport.ViewportTransform(Mat33_1.default.identity);\n        }\n        const canvasPos = this.editor.viewport.screenToCanvas(screenPos);\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without including translation\n        const translation = toCanvas.transformVec3(Vec3_1.default.of(-delta.x, -delta.y, 0));\n        const pinchZoomScaleFactor = 1.04;\n        const transformUpdate = Mat33_1.default.scaling2D(Math.pow(pinchZoomScaleFactor, -delta.z), canvasPos).rightMul(Mat33_1.default.translation(translation));\n        this.updateTransform(transformUpdate);\n        return true;\n    }\n    onKeyPress({ key }) {\n        let translation = Vec2_1.Vec2.zero;\n        let scale = 1;\n        let rotation = 0;\n        switch (key) {\n            case 'a':\n            case 'h':\n            case 'ArrowLeft':\n                translation = Vec2_1.Vec2.of(-1, 0);\n                break;\n            case 'd':\n            case 'l':\n            case 'ArrowRight':\n                translation = Vec2_1.Vec2.of(1, 0);\n                break;\n            case 'k':\n            case 'ArrowUp':\n                translation = Vec2_1.Vec2.of(0, -1);\n                break;\n            case 'j':\n            case 'ArrowDown':\n                translation = Vec2_1.Vec2.of(0, 1);\n                break;\n            case 'w':\n                scale = 1 / 2;\n                break;\n            case 's':\n                scale = 2;\n                break;\n            case 'r':\n                rotation = 1;\n                break;\n            case 'R':\n                rotation = -1;\n                break;\n            default:\n                return false;\n        }\n        // For each keypress,\n        translation = translation.times(30); // Move at most 30 units\n        rotation *= Math.PI / 8; // Rotate at most a sixteenth of a rotation\n        // Transform the canvas, not the viewport:\n        translation = translation.times(-1);\n        rotation = rotation * -1;\n        scale = 1 / scale;\n        const toCanvas = this.editor.viewport.screenToCanvasTransform;\n        // Transform without translating (treat toCanvas as a linear instead of\n        // an affine transformation).\n        translation = toCanvas.transformVec3(translation);\n        // Rotate/scale about the center of the canvas\n        const transformCenter = this.editor.viewport.visibleRect.center;\n        const transformUpdate = Mat33_1.default.scaling2D(scale, transformCenter).rightMul(Mat33_1.default.zRotation(rotation, transformCenter)).rightMul(Mat33_1.default.translation(translation));\n        this.updateTransform(transformUpdate);\n        return true;\n    }\n}\nexports[\"default\"] = PanZoom;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/PanZoom.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/Pen.ts":
/*!********************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/Pen.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Color4_1 = __webpack_require__(/*! ../Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nconst EditorImage_1 = __webpack_require__(/*! ../EditorImage */ \"./components/NoteEditor/ImageEditor/EditorImage.ts\");\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst Pointer_1 = __webpack_require__(/*! ../Pointer */ \"./components/NoteEditor/ImageEditor/Pointer.ts\");\nconst StrokeBuilder_1 = __webpack_require__(/*! ../StrokeBuilder */ \"./components/NoteEditor/ImageEditor/StrokeBuilder.ts\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nconst BaseTool_1 = __webpack_require__(/*! ./BaseTool */ \"./components/NoteEditor/ImageEditor/tools/BaseTool.ts\");\nconst ToolController_1 = __webpack_require__(/*! ./ToolController */ \"./components/NoteEditor/ImageEditor/tools/ToolController.ts\");\nclass Pen extends BaseTool_1.default {\n    constructor(editor, color = Color4_1.default.purple, thickness = 16.0) {\n        super(editor.notifier);\n        this.editor = editor;\n        this.color = color;\n        this.thickness = thickness;\n        this.kind = ToolController_1.ToolType.Pen;\n    }\n    getPressureMultiplier() {\n        return 1 / this.editor.viewport.getScaleFactor() * this.thickness;\n    }\n    getStrokePoint(pointer) {\n        var _a;\n        const minPressure = 0.3;\n        const pressure = Math.max((_a = pointer.pressure) !== null && _a !== void 0 ? _a : 1.0, minPressure);\n        return {\n            pos: pointer.canvasPos,\n            width: pressure * this.getPressureMultiplier(),\n            color: this.color,\n            time: pointer.timeStamp,\n        };\n    }\n    addPointToStroke(pointer) {\n        this.builder.addPoint(this.getStrokePoint(pointer));\n        this.editor.clearWetInk();\n        this.editor.drawWetInk(...this.builder.preview());\n    }\n    onPointerDown({ current, allPointers }) {\n        if (allPointers.length === 1 || current.device === Pointer_1.PointerDevice.Pen) {\n            // Don't smooth if input is more than ± 7 pixels from the true curve, do smooth if\n            // less than ± 2 px from the curve.\n            const canvasTransform = this.editor.viewport.screenToCanvasTransform;\n            const maxSmoothingDist = canvasTransform.transformVec3(Vec2_1.Vec2.unitX).magnitude() * 7;\n            const minSmoothingDist = canvasTransform.transformVec3(Vec2_1.Vec2.unitX).magnitude() * 2;\n            this.builder = new StrokeBuilder_1.default(this.getStrokePoint(current), minSmoothingDist, maxSmoothingDist);\n            return true;\n        }\n        return false;\n    }\n    onPointerMove({ current }) {\n        this.addPointToStroke(current);\n    }\n    onPointerUp({ current }) {\n        if (!this.builder) {\n            return;\n        }\n        this.addPointToStroke(current);\n        if (this.builder && current.isPrimary) {\n            const stroke = this.builder.build();\n            this.editor.clearWetInk();\n            this.editor.drawWetInk(...this.builder.preview());\n            const canFlatten = true;\n            const action = new EditorImage_1.default.AddElementCommand(stroke, canFlatten);\n            this.editor.dispatch(action);\n        }\n        this.builder = null;\n        this.editor.clearWetInk();\n    }\n    onGestureCancel() {\n        this.editor.clearWetInk();\n    }\n    noteUpdated() {\n        this.editor.notifier.dispatch(types_1.EditorEventType.ToolUpdated, {\n            kind: types_1.EditorEventType.ToolUpdated,\n            tool: this,\n        });\n    }\n    setColor(color) {\n        if (color.toHexString() !== this.color.toHexString()) {\n            this.color = color;\n            this.noteUpdated();\n        }\n    }\n    setThickness(thickness) {\n        if (thickness !== this.thickness) {\n            this.thickness = thickness;\n            this.noteUpdated();\n        }\n    }\n    getThickness() { return this.thickness; }\n    getColor() { return this.color; }\n}\nexports[\"default\"] = Pen;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/Pen.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/SelectionTool.ts":
/*!******************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/SelectionTool.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Mat33_1 = __webpack_require__(/*! ../geometry/Mat33 */ \"./components/NoteEditor/ImageEditor/geometry/Mat33.ts\");\n// import Mat33 from \"../geometry/Mat33\";\nconst Rect2_1 = __webpack_require__(/*! ../geometry/Rect2 */ \"./components/NoteEditor/ImageEditor/geometry/Rect2.ts\");\nconst Vec2_1 = __webpack_require__(/*! ../geometry/Vec2 */ \"./components/NoteEditor/ImageEditor/geometry/Vec2.ts\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nconst Viewport_1 = __webpack_require__(/*! ../Viewport */ \"./components/NoteEditor/ImageEditor/Viewport.ts\");\nconst BaseTool_1 = __webpack_require__(/*! ./BaseTool */ \"./components/NoteEditor/ImageEditor/tools/BaseTool.ts\");\nconst ToolController_1 = __webpack_require__(/*! ./ToolController */ \"./components/NoteEditor/ImageEditor/tools/ToolController.ts\");\nconst handleScreenSize = 30;\nconst styles = `\n\t.handleOverlay {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n\n\t.handleOverlay > .selectionBox {\n\t\tposition: fixed;\n\t\tz-index: 0;\n\t\ttransform-origin: center;\n\t}\n\n\t.handleOverlay > .selectionBox .draggableBackground {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tbottom: 0;\n\n\t\tbackground-color: rgba(255, 100, 255, 0.5);\n\t\tborder: 1px solid #ffccff;\n\t}\n\n\t.handleOverlay > .selectionBox .resizeCorner {\n\t\twidth: ${handleScreenSize}px;\n\t\theight: ${handleScreenSize}px;\n\t\tmargin-right: -${handleScreenSize / 2}px;\n\t\tmargin-bottom: -${handleScreenSize / 2}px;\n\n\t\tposition: absolute;\n\t\tbottom: 0;\n\t\tright: 0;\n\n\t\topacity: 0.8;\n\t\tbackground-color: white;\n\t\tborder: 1px solid black;\n\t}\n\n\t.handleOverlay > .selectionBox .rotateCircleContainer {\n\t\tposition: absolute;\n\t\ttop: 50%;\n\t\tbottom: 50%;\n\t\tleft: 50%;\n\t\tright: 50%;\n\t}\n\n\t.handleOverlay .rotateCircle {\n\t\twidth: ${handleScreenSize}px;\n\t\theight: ${handleScreenSize}px;\n\t\tmargin-left: -${handleScreenSize / 2}px;\n\t\tmargin-top: -${handleScreenSize / 2}px;\n\t\topacity: 0.8;\n\n\t\tborder: 1px solid black;\n\t\tbackground-color: white;\n\t\tborder-radius: 100%;\n\t}\n`;\nconst makeDraggable = (element, onDrag, onDragEnd) => {\n    element.style.touchAction = 'none';\n    let down = false;\n    // Work around a Safari bug\n    element.addEventListener('touchstart', evt => evt.preventDefault());\n    let lastX;\n    let lastY;\n    element.addEventListener('pointerdown', event => {\n        if (event.isPrimary) {\n            down = true;\n            element.setPointerCapture(event.pointerId);\n            lastX = event.pageX;\n            lastY = event.pageY;\n            return true;\n        }\n        return false;\n    });\n    element.addEventListener('pointermove', event => {\n        if (event.isPrimary && down) {\n            // Safari/iOS doesn't seem to support movementX/movementY on pointer events.\n            // Calculate manually:\n            const delta = Vec2_1.Vec2.of(event.pageX - lastX, event.pageY - lastY);\n            onDrag(delta, Vec2_1.Vec2.of(event.offsetX, event.offsetY));\n            lastX = event.pageX;\n            lastY = event.pageY;\n            return true;\n        }\n        return false;\n    });\n    const onPointerEnd = (event) => {\n        if (event.isPrimary) {\n            down = false;\n            onDragEnd();\n            return true;\n        }\n        return false;\n    };\n    element.addEventListener('pointerup', onPointerEnd);\n    element.addEventListener('pointercancel', onPointerEnd);\n};\nclass Selection {\n    constructor(startPoint, editor) {\n        this.startPoint = startPoint;\n        this.editor = editor;\n        this.boxRotation = this.editor.viewport.getRotationAngle();\n        this.selectedElems = [];\n        this.region = Rect2_1.default.bboxOf([startPoint]);\n        // Create draggable rectangles\n        this.backgroundBox = document.createElement('div');\n        const draggableBackground = document.createElement('div');\n        const resizeCorner = document.createElement('div');\n        this.rotateCircle = document.createElement('div');\n        const rotateCircleContainer = document.createElement('div');\n        this.backgroundBox.classList.add('selectionBox');\n        draggableBackground.classList.add('draggableBackground');\n        resizeCorner.classList.add('resizeCorner');\n        this.rotateCircle.classList.add('rotateCircle');\n        rotateCircleContainer.classList.add('rotateCircleContainer');\n        rotateCircleContainer.appendChild(this.rotateCircle);\n        this.backgroundBox.appendChild(draggableBackground);\n        this.backgroundBox.appendChild(rotateCircleContainer);\n        this.backgroundBox.appendChild(resizeCorner);\n        let transformationCommands = [];\n        let transform = Mat33_1.default.identity;\n        // Maximum number of strokes to transform without a re-render.\n        const updateChunkSize = 20;\n        // Apply a large transformation in chunks.\n        // If [apply] is false, the commands are unapplied.\n        const asyncTransformElems = (editor, transformCmds, apply) => __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < transformCmds.length; i += updateChunkSize) {\n                editor.showLoadingWarning(i / transformCmds.length);\n                for (let j = i; j < transformCmds.length && j < i + updateChunkSize; j++) {\n                    const cmd = transformCmds[j];\n                    if (apply) {\n                        cmd.apply(editor);\n                    }\n                    else {\n                        cmd.unapply(editor);\n                    }\n                }\n                // Re-render to show progress, but only if we're not done.\n                if (i + updateChunkSize < transformCmds.length) {\n                    yield new Promise(resolve => {\n                        editor.rerender();\n                        requestAnimationFrame(resolve);\n                    });\n                }\n            }\n            editor.hideLoadingWarning();\n        });\n        const computeTransformCommands = () => {\n            return this.selectedElems.map(elem => {\n                return elem.transformBy(transform);\n            });\n        };\n        const applyTransformCmds = () => {\n            transformationCommands.forEach(cmd => {\n                cmd.unapply(this.editor);\n            });\n            const fullTransform = transform;\n            const inverseTransform = transform.inverse();\n            const deltaBoxRotation = this.boxRotation;\n            const currentTransfmCommands = computeTransformCommands();\n            // Reset for the next drag\n            transformationCommands = [];\n            transform = Mat33_1.default.identity;\n            this.region = this.region.transformedBoundingBox(inverseTransform);\n            // Make the commands undo-able\n            this.editor.dispatch({\n                apply: (editor) => __awaiter(this, void 0, void 0, function* () {\n                    // Approximate the new selection\n                    this.region = this.region.transformedBoundingBox(fullTransform);\n                    this.boxRotation += deltaBoxRotation;\n                    this.updateUI();\n                    yield asyncTransformElems(editor, currentTransfmCommands, true);\n                    this.recomputeRegion();\n                    this.updateUI();\n                }),\n                unapply: (editor) => __awaiter(this, void 0, void 0, function* () {\n                    this.region = this.region.transformedBoundingBox(inverseTransform);\n                    this.boxRotation -= deltaBoxRotation;\n                    this.updateUI();\n                    yield asyncTransformElems(editor, currentTransfmCommands, false);\n                    this.recomputeRegion();\n                    this.updateUI();\n                }),\n            });\n        };\n        const previewTransformCmds = () => {\n            // Don't render what we're moving if it's likely to be slow.\n            if (this.selectedElems.length > updateChunkSize) {\n                this.updateUI();\n                return;\n            }\n            transformationCommands.forEach(cmd => cmd.unapply(this.editor));\n            transformationCommands = computeTransformCommands();\n            transformationCommands.forEach(cmd => cmd.apply(this.editor));\n            this.updateUI();\n        };\n        makeDraggable(draggableBackground, (deltaPosition) => {\n            // Re-scale the change in position\n            // (use a Vec3 transform to avoid translating deltaPosition)\n            deltaPosition = this.editor.viewport.screenToCanvasTransform.transformVec3(deltaPosition);\n            // Snap position to a multiple of 10 (additional decimal points lead to larger files).\n            deltaPosition = this.editor.viewport.roundPoint(deltaPosition);\n            this.region = this.region.translatedBy(deltaPosition);\n            transform = transform.rightMul(Mat33_1.default.translation(deltaPosition));\n            previewTransformCmds();\n        }, applyTransformCmds);\n        makeDraggable(resizeCorner, (deltaPosition) => {\n            deltaPosition = this.editor.viewport.screenToCanvasTransform.transformVec3(deltaPosition);\n            deltaPosition = this.editor.viewport.roundPoint(deltaPosition);\n            const oldWidth = this.region.w;\n            const oldHeight = this.region.h;\n            const newSize = this.region.size.plus(deltaPosition);\n            if (newSize.y > 0 && newSize.x > 0) {\n                this.region = this.region.resizedTo(newSize);\n                const scaleFactor = Vec2_1.Vec2.of(this.region.w / oldWidth, this.region.h / oldHeight);\n                const currentTransfm = Mat33_1.default.scaling2D(scaleFactor, this.region.topLeft);\n                transform = transform.rightMul(currentTransfm);\n                previewTransformCmds();\n            }\n        }, applyTransformCmds);\n        makeDraggable(this.rotateCircle, (_deltaPosition, offset) => {\n            this.boxRotation = this.boxRotation % (2 * Math.PI);\n            if (this.boxRotation < 0) {\n                this.boxRotation += 2 * Math.PI;\n            }\n            let targetRotation = offset.angle();\n            targetRotation = targetRotation % (2 * Math.PI);\n            if (targetRotation < 0) {\n                targetRotation += 2 * Math.PI;\n            }\n            let deltaRotation = (targetRotation - this.boxRotation);\n            const rotationStep = Math.PI / 12;\n            if (Math.abs(deltaRotation) < rotationStep || !isFinite(deltaRotation)) {\n                return;\n            }\n            else {\n                const rotationDirection = Math.sign(deltaRotation);\n                // Step exactly one rotationStep\n                deltaRotation = Math.floor(Math.abs(deltaRotation) / rotationStep) * rotationStep;\n                deltaRotation *= rotationDirection;\n            }\n            transform = transform.rightMul(Mat33_1.default.zRotation(deltaRotation, this.region.center));\n            this.boxRotation += deltaRotation;\n            previewTransformCmds();\n        }, applyTransformCmds);\n    }\n    appendBackgroundBoxTo(elem) {\n        if (this.backgroundBox.parentElement) {\n            this.backgroundBox.remove();\n        }\n        elem.appendChild(this.backgroundBox);\n    }\n    setToPoint(point) {\n        this.region = this.region.grownToPoint(point);\n        this.recomputeBoxRotation();\n        this.updateUI();\n    }\n    cancelSelection() {\n        if (this.backgroundBox.parentElement) {\n            this.backgroundBox.remove();\n        }\n    }\n    // Find the objects corresponding to this in the document,\n    // select them.\n    // Returns false iff nothing was selected.\n    resolveToObjects() {\n        // Grow the rectangle, if necessary\n        if (this.region.w === 0 || this.region.h === 0) {\n            const padding = this.editor.viewport.visibleRect.maxDimension / 100;\n            this.region = Rect2_1.default.bboxOf(this.region.corners, padding);\n        }\n        this.selectedElems = this.editor.image.getElementsIntersectingRegion(this.region).filter(elem => {\n            if (this.region.containsRect(elem.getBBox())) {\n                return true;\n            }\n            else if (this.region.getEdges().some(edge => elem.intersects(edge))) {\n                return true;\n            }\n            return false;\n        });\n        // Find the bounding box of all selected elements.\n        if (!this.recomputeRegion()) {\n            return false;\n        }\n        this.updateUI();\n        return true;\n    }\n    // Recompute this' region from the selected elements. Resets rotation to zero.\n    // Returns false if the selection is empty.\n    recomputeRegion() {\n        const newRegion = this.selectedElems.reduce((accumulator, elem) => {\n            return (accumulator !== null && accumulator !== void 0 ? accumulator : elem.getBBox()).union(elem.getBBox());\n        }, null);\n        if (!newRegion) {\n            this.cancelSelection();\n            return false;\n        }\n        this.region = newRegion;\n        const minSize = this.getMinCanvasSize();\n        if (this.region.w < minSize || this.region.h < minSize) {\n            // Add padding\n            const padding = minSize / 2;\n            this.region = Rect2_1.default.bboxOf(this.region.corners, padding);\n        }\n        this.recomputeBoxRotation();\n        return true;\n    }\n    getMinCanvasSize() {\n        const canvasHandleSize = handleScreenSize / this.editor.viewport.getScaleFactor();\n        return canvasHandleSize * 2;\n    }\n    recomputeBoxRotation() {\n        this.boxRotation = this.editor.viewport.getRotationAngle();\n    }\n    updateUI() {\n        if (!this.backgroundBox) {\n            return;\n        }\n        const rightSideDirection = this.region.topRight.minus(this.region.bottomRight);\n        const topSideDirection = this.region.topLeft.minus(this.region.topRight);\n        const toScreen = this.editor.viewport.canvasToScreenTransform;\n        const centerOnScreen = toScreen.transformVec2(this.region.center);\n        const heightOnScreen = toScreen.transformVec3(rightSideDirection).magnitude();\n        const widthOnScreen = toScreen.transformVec3(topSideDirection).magnitude();\n        this.backgroundBox.style.left = `${centerOnScreen.x - widthOnScreen / 2}px`;\n        this.backgroundBox.style.top = `${centerOnScreen.y - heightOnScreen / 2}px`;\n        this.backgroundBox.style.width = `${widthOnScreen}px`;\n        this.backgroundBox.style.height = `${heightOnScreen}px`;\n        const rotationDeg = this.boxRotation * 180 / Math.PI;\n        this.backgroundBox.style.transform = `rotate(${rotationDeg}deg)`;\n        this.rotateCircle.style.transform = `rotate(${-rotationDeg}deg)`;\n    }\n}\nclass SelectionTool extends BaseTool_1.default {\n    constructor(editor) {\n        super(editor.notifier);\n        this.editor = editor;\n        this.kind = ToolController_1.ToolType.Selection;\n        this.handleOverlay = document.createElement('div');\n        editor.createHTMLOverlay(this.handleOverlay);\n        editor.addStyleSheet(styles);\n        this.handleOverlay.style.display = 'none';\n        this.handleOverlay.classList.add('handleOverlay');\n        editor.notifier.on(types_1.EditorEventType.ViewportChanged, _data => {\n            var _a, _b;\n            (_a = this.selectionBox) === null || _a === void 0 ? void 0 : _a.recomputeRegion();\n            (_b = this.selectionBox) === null || _b === void 0 ? void 0 : _b.updateUI();\n        });\n    }\n    onPointerDown(event) {\n        if (event.allPointers.length === 1 && event.current.isPrimary) {\n            this.prevSelectionBox = this.selectionBox;\n            this.selectionBox = new Selection(event.current.canvasPos, this.editor);\n            // Remove any previous selection rects\n            this.handleOverlay.replaceChildren();\n            this.selectionBox.appendBackgroundBoxTo(this.handleOverlay);\n            return true;\n        }\n        return false;\n    }\n    onPointerMove(event) {\n        this.selectionBox.setToPoint(event.current.canvasPos);\n    }\n    onGestureEnd() {\n        // Expand/shrink the selection rectangle, if applicable\n        const hasSelection = this.selectionBox.resolveToObjects();\n        if (hasSelection) {\n            const visibleRect = this.editor.viewport.visibleRect;\n            const selectionRect = this.selectionBox.region;\n            // Try to move the selection within the center 2/3rds of the viewport.\n            const targetRect = visibleRect.transformedBoundingBox(Mat33_1.default.scaling2D(2 / 3, visibleRect.center));\n            // Ensure that the selection fits within the target\n            if (targetRect.w < selectionRect.w || targetRect.h < selectionRect.h) {\n                const multiplier = Math.max(selectionRect.w / targetRect.w, selectionRect.h / targetRect.h);\n                const visibleRectTransform = Mat33_1.default.scaling2D(multiplier, targetRect.topLeft);\n                const viewportContentTransform = visibleRectTransform.inverse();\n                (new Viewport_1.default.ViewportTransform(viewportContentTransform)).apply(this.editor);\n            }\n            // Ensure that the top left is visible\n            if (!targetRect.containsRect(selectionRect)) {\n                // target position - current position\n                const translation = selectionRect.center.minus(targetRect.center);\n                const visibleRectTransform = Mat33_1.default.translation(translation);\n                const viewportContentTransform = visibleRectTransform.inverse();\n                (new Viewport_1.default.ViewportTransform(viewportContentTransform)).apply(this.editor);\n            }\n        }\n    }\n    onPointerUp(event) {\n        this.selectionBox.setToPoint(event.current.canvasPos);\n        this.onGestureEnd();\n    }\n    onGestureCancel() {\n        var _a, _b;\n        // Revert to the previous selection, if any.\n        (_a = this.selectionBox) === null || _a === void 0 ? void 0 : _a.cancelSelection();\n        this.selectionBox = this.prevSelectionBox;\n        (_b = this.selectionBox) === null || _b === void 0 ? void 0 : _b.appendBackgroundBoxTo(this.handleOverlay);\n    }\n    setEnabled(enabled) {\n        super.setEnabled(enabled);\n        // Clear the selection\n        this.handleOverlay.replaceChildren();\n        this.selectionBox = null;\n        this.handleOverlay.style.display = enabled ? 'block' : 'none';\n    }\n    // Get the object responsible for displaying this' selection.\n    getSelection() {\n        return this.selectionBox;\n    }\n}\nexports[\"default\"] = SelectionTool;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/SelectionTool.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/ToolController.ts":
/*!*******************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/ToolController.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ToolController_instances, _ToolController_setToolEnabled;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ToolType = void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"./components/NoteEditor/ImageEditor/types.ts\");\nconst PanZoom_1 = __webpack_require__(/*! ./PanZoom */ \"./components/NoteEditor/ImageEditor/tools/PanZoom.ts\");\nconst Pen_1 = __webpack_require__(/*! ./Pen */ \"./components/NoteEditor/ImageEditor/tools/Pen.ts\");\nconst ToolEnabledGroup_1 = __webpack_require__(/*! ./ToolEnabledGroup */ \"./components/NoteEditor/ImageEditor/tools/ToolEnabledGroup.ts\");\nconst Eraser_1 = __webpack_require__(/*! ./Eraser */ \"./components/NoteEditor/ImageEditor/tools/Eraser.ts\");\nconst SelectionTool_1 = __webpack_require__(/*! ./SelectionTool */ \"./components/NoteEditor/ImageEditor/tools/SelectionTool.ts\");\nconst Color4_1 = __webpack_require__(/*! ../Color4 */ \"./components/NoteEditor/ImageEditor/Color4.ts\");\nvar ToolType;\n(function (ToolType) {\n    ToolType[ToolType[\"TouchPanZoom\"] = 0] = \"TouchPanZoom\";\n    ToolType[ToolType[\"Pen\"] = 1] = \"Pen\";\n    ToolType[ToolType[\"Selection\"] = 2] = \"Selection\";\n    ToolType[ToolType[\"Eraser\"] = 3] = \"Eraser\";\n    ToolType[ToolType[\"PanZoom\"] = 4] = \"PanZoom\";\n})(ToolType = exports.ToolType || (exports.ToolType = {}));\n/**\n * Controller for interactive tools/modes. See `commands/` for non-interactive\n * tools.\n */\nclass ToolController {\n    constructor(editor) {\n        _ToolController_instances.add(this);\n        const primaryToolEnabledGroup = new ToolEnabledGroup_1.default();\n        const touchPanZoom = new PanZoom_1.default(editor, PanZoom_1.PanZoomMode.OneFingerGestures);\n        const primaryPenTool = new Pen_1.default(editor);\n        const primaryTools = [\n            new SelectionTool_1.default(editor),\n            new Eraser_1.default(editor),\n            // Three pens\n            primaryPenTool,\n            new Pen_1.default(editor, Color4_1.default.clay, 8),\n            // Highlighter-like pen with width=64\n            new Pen_1.default(editor, Color4_1.default.ofRGBA(1, 1, 0, 0.5), 64),\n        ];\n        this.tools = [\n            touchPanZoom,\n            ...primaryTools,\n            new PanZoom_1.default(editor, PanZoom_1.PanZoomMode.TwoFingerGestures | PanZoom_1.PanZoomMode.AnyDevice),\n        ];\n        primaryTools.forEach(tool => tool.setToolGroup(primaryToolEnabledGroup));\n        touchPanZoom.setEnabled(false);\n        primaryPenTool.setEnabled(true);\n        this.activeTool = null;\n    }\n    /**\n     * Sends an input event to the active tool, returns whether the event was handled.\n     * @param event Event to dispatch. If a `PointerDownEvt`, the active tool will be changed.\n     *              `WheelEvt`s are dispatched to the first tool which handles them. Other events\n     *              are dispatched to the active tool.\n     * @return true iff the event was handled.\n     */\n    dispatchInputEvent(event) {\n        var _a, _b;\n        let handled;\n        if (event.kind === types_1.InputEvtType.PointerDownEvt) {\n            for (const tool of this.tools) {\n                if (tool.isEnabled() && tool.onPointerDown(event)) {\n                    if (this.activeTool !== tool) {\n                        (_a = this.activeTool) === null || _a === void 0 ? void 0 : _a.onGestureCancel();\n                    }\n                    this.activeTool = tool;\n                    handled = true;\n                    break;\n                }\n            }\n        }\n        else if (event.kind === types_1.InputEvtType.PointerUpEvt) {\n            (_b = this.activeTool) === null || _b === void 0 ? void 0 : _b.onPointerUp(event);\n            this.activeTool = null;\n            handled = true;\n        }\n        else if (event.kind === types_1.InputEvtType.WheelEvt || event.kind === types_1.InputEvtType.KeyPressEvent) {\n            const isKeyPressEvt = event.kind === types_1.InputEvtType.KeyPressEvent;\n            const isWheelEvt = event.kind === types_1.InputEvtType.WheelEvt;\n            for (const tool of this.tools) {\n                if (!tool.isEnabled()) {\n                    continue;\n                }\n                const wheelResult = isWheelEvt && tool.onWheel(event);\n                const keyPressResult = isKeyPressEvt && tool.onKeyPress(event);\n                handled = keyPressResult || wheelResult;\n                if (handled) {\n                    break;\n                }\n            }\n        }\n        else if (this.activeTool !== null) {\n            let allCasesHandledGuard;\n            switch (event.kind) {\n                case types_1.InputEvtType.PointerMoveEvt:\n                    this.activeTool.onPointerMove(event);\n                    break;\n                case types_1.InputEvtType.GestureCancelEvt:\n                    this.activeTool.onGestureCancel();\n                    this.activeTool = null;\n                    break;\n                default:\n                    allCasesHandledGuard = event;\n                    return allCasesHandledGuard;\n            }\n            handled = true;\n        }\n        else {\n            handled = false;\n        }\n        return handled;\n    }\n    getMatchingTools(kind) {\n        return this.tools.filter(tool => tool.kind === kind);\n    }\n    /**\n     * @param kind kind of tool to search for (e.g. ToolType.Pen would set\n     *             whether the pen tool is enabled)\n     * @param enabled Whether all matching tools should be enabled.\n     * @returns A `Command` that, when applied, enables/disables all matching tools.\n     */\n    static setToolEnabled(kind, enabled) {\n        return new class {\n            constructor() {\n                this.wasEnabled = null;\n            }\n            apply(editor) {\n                var _a;\n                this.wasEnabled = editor.toolController.isToolEnabled(kind);\n                __classPrivateFieldGet((_a = editor.toolController), _ToolController_instances, \"m\", _ToolController_setToolEnabled).call(_a, kind, enabled);\n            }\n            unapply(editor) {\n                var _a;\n                // Can't unapply if not applied before\n                if (this.wasEnabled !== null) {\n                    __classPrivateFieldGet((_a = editor.toolController), _ToolController_instances, \"m\", _ToolController_setToolEnabled).call(_a, kind, this.wasEnabled);\n                }\n            }\n        };\n    }\n    /**\n     * @returns true iff any tools of the given kind are enabled.\n     */\n    isToolEnabled(kind) {\n        const matchingTools = this.tools.filter(tool => tool.kind === kind);\n        return matchingTools.some((tool) => tool.isEnabled());\n    }\n}\nexports[\"default\"] = ToolController;\n_ToolController_instances = new WeakSet(), _ToolController_setToolEnabled = function _ToolController_setToolEnabled(kind, enabled) {\n    const matchingTools = this.tools.filter(tool => tool.kind === kind);\n    for (const tool of matchingTools) {\n        tool.setEnabled(enabled);\n        console.log('Set', tool, '', enabled);\n    }\n};\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/ToolController.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/tools/ToolEnabledGroup.ts":
/*!*********************************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/tools/ToolEnabledGroup.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/** Connects a group of tools -- eactly one tool in the group must be enabled. */\nclass ToolEnabledGroup {\n    constructor() { }\n    notifyEnabled(tool) {\n        var _a;\n        if (tool !== this.activeTool) {\n            (_a = this.activeTool) === null || _a === void 0 ? void 0 : _a.setEnabled(false);\n            this.activeTool = tool;\n        }\n    }\n}\nexports[\"default\"] = ToolEnabledGroup;\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/tools/ToolEnabledGroup.ts?");

/***/ }),

/***/ "./components/NoteEditor/ImageEditor/types.ts":
/*!****************************************************!*\
  !*** ./components/NoteEditor/ImageEditor/types.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/**\n * Types relevant to the image editor\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorEventType = exports.InputEvtType = void 0;\nvar InputEvtType;\n(function (InputEvtType) {\n    InputEvtType[InputEvtType[\"PointerDownEvt\"] = 0] = \"PointerDownEvt\";\n    InputEvtType[InputEvtType[\"PointerMoveEvt\"] = 1] = \"PointerMoveEvt\";\n    InputEvtType[InputEvtType[\"PointerUpEvt\"] = 2] = \"PointerUpEvt\";\n    InputEvtType[InputEvtType[\"GestureCancelEvt\"] = 3] = \"GestureCancelEvt\";\n    InputEvtType[InputEvtType[\"WheelEvt\"] = 4] = \"WheelEvt\";\n    InputEvtType[InputEvtType[\"KeyPressEvent\"] = 5] = \"KeyPressEvent\";\n})(InputEvtType = exports.InputEvtType || (exports.InputEvtType = {}));\nvar EditorEventType;\n(function (EditorEventType) {\n    EditorEventType[EditorEventType[\"ToolEnabled\"] = 0] = \"ToolEnabled\";\n    EditorEventType[EditorEventType[\"ToolDisabled\"] = 1] = \"ToolDisabled\";\n    EditorEventType[EditorEventType[\"ToolUpdated\"] = 2] = \"ToolUpdated\";\n    EditorEventType[EditorEventType[\"ObjectAdded\"] = 3] = \"ObjectAdded\";\n    EditorEventType[EditorEventType[\"ViewportChanged\"] = 4] = \"ViewportChanged\";\n    EditorEventType[EditorEventType[\"DisplayResized\"] = 5] = \"DisplayResized\";\n})(EditorEventType = exports.EditorEventType || (exports.EditorEventType = {}));\n\n\n//# sourceURL=webpack://svgEditor/./components/NoteEditor/ImageEditor/types.ts?");

/***/ }),

/***/ "../lib/EventDispatcher.ts":
/*!*********************************!*\
  !*** ../lib/EventDispatcher.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Sends notifications/allows listening for events.\n *\n * @param EventKeyType Possible identifiers for events.\n * @param EventType Type of data associated with events.\n */\nclass EventDispatcher {\n    constructor() {\n        this.listeners = {};\n    }\n    /**\n     * Sends a notification to all listeners subscribed to the given [notificationKind].\n     * @param eventType Type of the notification.\n     * @param value Data associated with the notification.\n     */\n    dispatch(eventName, event = null) {\n        if (!this.listeners[eventName])\n            return;\n        const ls = this.listeners[eventName];\n        for (let i = 0; i < ls.length; i++) {\n            ls[i](event);\n        }\n    }\n    /**\n     * Listen for a specific type of event.\n     *\n     * @param eventType Type of event that causes `callback` to be called.\n     * @param callback Callback called when an event of `eventType` is fired.\n     * @returns An object with a `remove` function. Calling `remove` unregisters the listener.\n     */\n    on(eventName, callback) {\n        if (!this.listeners[eventName])\n            this.listeners[eventName] = [];\n        this.listeners[eventName].push(callback);\n        return {\n            /**\n             * Stop listening.\n             * @return false if the listener has already been removed, true otherwise.\n             */\n            remove: () => {\n                const originalListeners = this.listeners[eventName];\n                this.off(eventName, callback);\n                return originalListeners.length !== this.listeners[eventName].length;\n            },\n        };\n    }\n    /**\n     * Remove a listener. Equivalent to calling `.remove()` on the object returned\n     * by `on`.\n     * @see on\n     */\n    off(eventName, callback) {\n        if (!this.listeners[eventName])\n            return;\n        // Replace the current list of listeners with a new, shortened list.\n        // This allows any iterators over this.listeners to continue iterating\n        // without skipping elements.\n        this.listeners[eventName] = this.listeners[eventName].filter(otherCallback => otherCallback !== callback);\n    }\n}\nexports[\"default\"] = EventDispatcher;\n\n\n//# sourceURL=webpack://svgEditor/../lib/EventDispatcher.ts?");

/***/ }),

/***/ "./node_modules/@melloware/coloris/dist/umd/coloris.js":
/*!*************************************************************!*\
  !*** ./node_modules/@melloware/coloris/dist/umd/coloris.js ***!
  \*************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n\n// Uses Node, AMD or browser globals to create a module.\n\n// If you want something that will work in other stricter CommonJS environments,\n// or if you need to create a circular dependency, see commonJsStrict.js\n\n// Defines a module \"returnExports\" that depends another module called \"b\".\n// Note that the name of the module is implied by the file name. It is best\n// if the file name and the exported global have matching names.\n\n// If the 'b' module also uses this type of boilerplate, then\n// in the browser, it will create a global .b that is used below.\n\n// If you do not want to support the browser global path, then you\n// can remove the `root` use and the passing `this` as the first arg to\n// the top function.\n\n// if the module has no dependencies, the above pattern can be simplified to\n(function (root, factory) {\n  if (true) {\n    // AMD. Register as an unnamed module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else\n  {}\n})(typeof self !== 'undefined' ? self : void 0, function () {\n  // Just return a value to define the module export.\n  // This example returns an object, but the module\n  // can return a function as the exported value.\n  /*!\r\n  * Copyright (c) 2021 Momo Bassit.\r\n  * Licensed under the MIT License (MIT)\r\n  * https://github.com/mdbassit/Coloris\r\n  */\n\n  return function (window, document, Math) {\n    var ctx = document.createElement('canvas').getContext('2d');\n    var currentColor = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 };\n    var container, picker, colorArea, colorAreaDims, colorMarker, colorPreview, colorValue, clearButton,\n    hueSlider, hueMarker, alphaSlider, alphaMarker, currentEl, currentFormat, oldColor;\n\n    // Default settings\n    var settings = {\n      el: '[data-coloris]',\n      parent: 'body',\n      theme: 'default',\n      themeMode: 'light',\n      wrap: true,\n      margin: 2,\n      format: 'hex',\n      formatToggle: false,\n      swatches: [],\n      swatchesOnly: false,\n      alpha: true,\n      forceAlpha: false,\n      focusInput: true,\n      selectInput: false,\n      inline: false,\n      defaultColor: '#000000',\n      clearButton: false,\n      clearLabel: 'Clear',\n      a11y: {\n        open: 'Open color picker',\n        close: 'Close color picker',\n        marker: 'Saturation: {s}. Brightness: {v}.',\n        hueSlider: 'Hue slider',\n        alphaSlider: 'Opacity slider',\n        input: 'Color value field',\n        format: 'Color format',\n        swatch: 'Color swatch',\n        instruction: 'Saturation and brightness selector. Use up, down, left and right arrow keys to select.' } };\n\n\n\n    // Virtual instances cache\n    var instances = {};\n    var currentInstanceId = '';\n    var defaultInstance = {};\n    var hasInstance = false;\n\n    /**\r\n     * Configure the color picker.\r\n     * @param {object} options Configuration options.\r\n     */\n    function configure(options) {\n      if (typeof options !== 'object') {\n        return;\n      }\n\n      for (var key in options) {\n        switch (key) {\n          case 'el':\n            bindFields(options.el);\n            if (options.wrap !== false) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'parent':\n            container = document.querySelector(options.parent);\n            if (container) {\n              container.appendChild(picker);\n              settings.parent = options.parent;\n\n              // document.body is special\n              if (container === document.body) {\n                container = null;\n              }\n            }\n            break;\n          case 'themeMode':\n            settings.themeMode = options.themeMode;\n            if (options.themeMode === 'auto' && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n              settings.themeMode = 'dark';\n            }\n          // The lack of a break statement is intentional\n          case 'theme':\n            if (options.theme) {\n              settings.theme = options.theme;\n            }\n\n            // Set the theme and color scheme\n            picker.className = \"clr-picker clr-\" + settings.theme + \" clr-\" + settings.themeMode;\n\n            // Update the color picker's position if inline mode is in use\n            if (settings.inline) {\n              updatePickerPosition();\n            }\n            break;\n          case 'margin':\n            options.margin *= 1;\n            settings.margin = !isNaN(options.margin) ? options.margin : settings.margin;\n            break;\n          case 'wrap':\n            if (options.el && options.wrap) {\n              wrapFields(options.el);\n            }\n            break;\n          case 'formatToggle':\n            settings.formatToggle = !!options.formatToggle;\n            getEl('clr-format').style.display = settings.formatToggle ? 'block' : 'none';\n            if (settings.formatToggle) {\n              settings.format = 'auto';\n            }\n            break;\n          case 'swatches':\n            if (Array.isArray(options.swatches)) {(function () {\n                var swatches = [];\n\n                options.swatches.forEach(function (swatch, i) {\n                  swatches.push(\"<button type=\\\"button\\\" id=\\\"clr-swatch-\" + i + \"\\\" aria-labelledby=\\\"clr-swatch-label clr-swatch-\" + i + \"\\\" style=\\\"color: \" + swatch + \";\\\">\" + swatch + \"</button>\");\n                });\n\n                getEl('clr-swatches').innerHTML = swatches.length ? \"<div>\" + swatches.join('') + \"</div>\" : '';\n                settings.swatches = options.swatches.slice();})();\n            }\n            break;\n          case 'swatchesOnly':\n            settings.swatchesOnly = !!options.swatchesOnly;\n            picker.setAttribute('data-minimal', settings.swatchesOnly);\n            break;\n          case 'alpha':\n            settings.alpha = !!options.alpha;\n            picker.setAttribute('data-alpha', settings.alpha);\n            break;\n          case 'inline':\n            settings.inline = !!options.inline;\n            picker.setAttribute('data-inline', settings.inline);\n\n            if (settings.inline) {\n              var defaultColor = options.defaultColor || settings.defaultColor;\n\n              currentFormat = getColorFormatFromStr(defaultColor);\n              updatePickerPosition();\n              setColorFromStr(defaultColor);\n            }\n            break;\n          case 'clearButton':\n            // Backward compatibility\n            if (typeof options.clearButton === 'object') {\n              if (options.clearButton.label) {\n                settings.clearLabel = options.clearButton.label;\n                clearButton.innerHTML = settings.clearLabel;\n              }\n\n              options.clearButton = options.clearButton.show;\n            }\n\n            settings.clearButton = !!options.clearButton;\n            clearButton.style.display = settings.clearButton ? 'block' : 'none';\n            break;\n          case 'clearLabel':\n            settings.clearLabel = options.clearLabel;\n            clearButton.innerHTML = settings.clearLabel;\n            break;\n          case 'a11y':\n            var labels = options.a11y;\n            var update = false;\n\n            if (typeof labels === 'object') {\n              for (var label in labels) {\n                if (labels[label] && settings.a11y[label]) {\n                  settings.a11y[label] = labels[label];\n                  update = true;\n                }\n              }\n            }\n\n            if (update) {\n              var openLabel = getEl('clr-open-label');\n              var swatchLabel = getEl('clr-swatch-label');\n\n              openLabel.innerHTML = settings.a11y.open;\n              swatchLabel.innerHTML = settings.a11y.swatch;\n              colorPreview.setAttribute('aria-label', settings.a11y.close);\n              hueSlider.setAttribute('aria-label', settings.a11y.hueSlider);\n              alphaSlider.setAttribute('aria-label', settings.a11y.alphaSlider);\n              colorValue.setAttribute('aria-label', settings.a11y.input);\n              colorArea.setAttribute('aria-label', settings.a11y.instruction);\n            }\n          default:\n            settings[key] = options[key];}\n\n      }\n    }\n\n    /**\r\n     * Add or update a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     * @param {Object} options Per-instance options to apply.\r\n     */\n    function setVirtualInstance(selector, options) {\n      if (typeof selector === 'string' && typeof options === 'object') {\n        instances[selector] = options;\n        hasInstance = true;\n      }\n    }\n\n    /**\r\n     * Remove a virtual instance.\r\n     * @param {String} selector The CSS selector of the elements to which the instance is attached.\r\n     */\n    function removeVirtualInstance(selector) {\n      delete instances[selector];\n\n      if (Object.keys(instances).length === 0) {\n        hasInstance = false;\n\n        if (selector === currentInstanceId) {\n          resetVirtualInstance();\n        }\n      }\n    }\n\n    /**\r\n     * Attach a virtual instance to an element if it matches a selector.\r\n     * @param {Object} element Target element that will receive a virtual instance if applicable.\r\n     */\n    function attachVirtualInstance(element) {\n      if (hasInstance) {\n        // These options can only be set globally, not per instance\n        var unsupportedOptions = ['el', 'wrap', 'inline', 'defaultColor', 'a11y'];var _loop = function _loop(\n\n        selector) {\n          var options = instances[selector];\n\n          // If the element matches an instance's CSS selector\n          if (element.matches(selector)) {\n            currentInstanceId = selector;\n            defaultInstance = {};\n\n            // Delete unsupported options\n            unsupportedOptions.forEach(function (option) {return delete options[option];});\n\n            // Back up the default options so we can restore them later\n            for (var option in options) {\n              defaultInstance[option] = Array.isArray(settings[option]) ? settings[option].slice() : settings[option];\n            }\n\n            // Set the instance's options\n            configure(options);\n            return \"break\";\n          }};for (var selector in instances) {var _ret = _loop(selector);if (_ret === \"break\") break;\n        }\n      }\n    }\n\n    /**\r\n     * Revert any per-instance options that were previously applied.\r\n     */\n    function resetVirtualInstance() {\n      if (Object.keys(defaultInstance).length > 0) {\n        configure(defaultInstance);\n        currentInstanceId = '';\n        defaultInstance = {};\n      }\n    }\n\n    /**\r\n     * Bind the color picker to input fields that match the selector.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function bindFields(selector) {\n      // Show the color picker on click on the input fields that match the selector\n      addListener(document, 'click', selector, function (event) {\n        // Skip if inline mode is in use\n        if (settings.inline) {\n          return;\n        }\n\n        // Apply any per-instance options first\n        attachVirtualInstance(event.target);\n\n        currentEl = event.target;\n        oldColor = currentEl.value;\n        currentFormat = getColorFormatFromStr(oldColor);\n        picker.classList.add('clr-open');\n\n        updatePickerPosition();\n        setColorFromStr(oldColor);\n\n        if (settings.focusInput || settings.selectInput) {\n          colorValue.focus({ preventScroll: true });\n        }\n\n        if (settings.selectInput) {\n          colorValue.select();\n        }\n\n        // Trigger an \"open\" event\n        currentEl.dispatchEvent(new Event('open', { bubbles: true }));\n      });\n\n      // Update the color preview of the input fields that match the selector\n      addListener(document, 'input', selector, function (event) {\n        var parent = event.target.parentNode;\n\n        // Only update the preview if the field has been previously wrapped\n        if (parent.classList.contains('clr-field')) {\n          parent.style.color = event.target.value;\n        }\n      });\n    }\n\n    /**\r\n     * Update the color picker's position and the color gradient's offset\r\n     */\n    function updatePickerPosition() {\n      var parent = container;\n      var scrollY = window.scrollY;\n      var pickerWidth = picker.offsetWidth;\n      var pickerHeight = picker.offsetHeight;\n      var reposition = { left: false, top: false };\n      var parentStyle, parentMarginTop, parentBorderTop;\n      var offset = { x: 0, y: 0 };\n\n      if (parent) {\n        parentStyle = window.getComputedStyle(parent);\n        parentMarginTop = parseFloat(parentStyle.marginTop);\n        parentBorderTop = parseFloat(parentStyle.borderTopWidth);\n\n        offset = parent.getBoundingClientRect();\n        offset.y += parentBorderTop + scrollY;\n      }\n\n      if (!settings.inline) {\n        var coords = currentEl.getBoundingClientRect();\n        var left = coords.x;\n        var top = scrollY + coords.y + coords.height + settings.margin;\n\n        // If the color picker is inside a custom container\n        // set the position relative to it\n        if (parent) {\n          left -= offset.x;\n          top -= offset.y;\n\n          if (left + pickerWidth > parent.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight > parent.clientHeight - parentMarginTop) {\n            top -= coords.height + pickerHeight + settings.margin * 2;\n            reposition.top = true;\n          }\n\n          top += parent.scrollTop;\n\n          // Otherwise set the position relative to the whole document\n        } else {\n          if (left + pickerWidth > document.documentElement.clientWidth) {\n            left += coords.width - pickerWidth;\n            reposition.left = true;\n          }\n\n          if (top + pickerHeight - scrollY > document.documentElement.clientHeight) {\n            top = scrollY + coords.y - pickerHeight - settings.margin;\n            reposition.top = true;\n          }\n        }\n\n        picker.classList.toggle('clr-left', reposition.left);\n        picker.classList.toggle('clr-top', reposition.top);\n        picker.style.left = left + \"px\";\n        picker.style.top = top + \"px\";\n      }\n\n      colorAreaDims = {\n        width: colorArea.offsetWidth,\n        height: colorArea.offsetHeight,\n        x: picker.offsetLeft + colorArea.offsetLeft + offset.x,\n        y: picker.offsetTop + colorArea.offsetTop + offset.y };\n\n    }\n\n    /**\r\n     * Wrap the linked input fields in a div that adds a color preview.\r\n     * @param {string} selector One or more selectors pointing to input fields.\r\n     */\n    function wrapFields(selector) {\n      document.querySelectorAll(selector).forEach(function (field) {\n        var parentNode = field.parentNode;\n\n        if (!parentNode.classList.contains('clr-field')) {\n          var wrapper = document.createElement('div');\n\n          wrapper.innerHTML = \"<button type=\\\"button\\\" aria-labelledby=\\\"clr-open-label\\\"></button>\";\n          parentNode.insertBefore(wrapper, field);\n          wrapper.setAttribute('class', 'clr-field');\n          wrapper.style.color = field.value;\n          wrapper.appendChild(field);\n        }\n      });\n    }\n\n    /**\r\n     * Close the color picker.\r\n     * @param {boolean} [revert] If true, revert the color to the original value.\r\n     */\n    function closePicker(revert) {\n      if (currentEl && !settings.inline) {\n        // Revert the color to the original value if needed\n        if (revert && oldColor !== currentEl.value) {\n          currentEl.value = oldColor;\n\n          // Trigger an \"input\" event to force update the thumbnail next to the input field\n          currentEl.dispatchEvent(new Event('input', { bubbles: true }));\n        }\n\n        if (oldColor !== currentEl.value) {\n          currentEl.dispatchEvent(new Event('change', { bubbles: true }));\n        }\n\n        // Hide the picker dialog\n        picker.classList.remove('clr-open');\n\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Trigger a \"close\" event\n        currentEl.dispatchEvent(new Event('close', { bubbles: true }));\n\n        if (settings.focusInput) {\n          currentEl.focus({ preventScroll: true });\n        }\n\n        currentEl = null;\n      }\n    }\n\n    /**\r\n     * Set the active color from a string.\r\n     * @param {string} str String representing a color.\r\n     */\n    function setColorFromStr(str) {\n      var rgba = strToRGBA(str);\n      var hsva = RGBAtoHSVA(rgba);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n\n      // Update the UI\n      hueSlider.value = hsva.h;\n      picker.style.color = \"hsl(\" + hsva.h + \", 100%, 50%)\";\n      hueMarker.style.left = hsva.h / 360 * 100 + \"%\";\n\n      colorMarker.style.left = colorAreaDims.width * hsva.s / 100 + \"px\";\n      colorMarker.style.top = colorAreaDims.height - colorAreaDims.height * hsva.v / 100 + \"px\";\n\n      alphaSlider.value = hsva.a * 100;\n      alphaMarker.style.left = hsva.a * 100 + \"%\";\n    }\n\n    /**\r\n     * Guess the color format from a string.\r\n     * @param {string} str String representing a color.\r\n     * @return {string} The color format.\r\n     */\n    function getColorFormatFromStr(str) {\n      var format = str.substring(0, 3).toLowerCase();\n\n      if (format === 'rgb' || format === 'hsl') {\n        return format;\n      }\n\n      return 'hex';\n    }\n\n    /**\r\n     * Copy the active color to the linked input field.\r\n     * @param {number} [color] Color value to override the active color.\r\n     */\n    function pickColor(color) {\n      color = color !== undefined ? color : colorValue.value;\n\n      if (currentEl) {\n        currentEl.value = color;\n        currentEl.dispatchEvent(new Event('input', { bubbles: true }));\n      }\n\n      document.dispatchEvent(new CustomEvent('coloris:pick', { detail: { color: color } }));\n    }\n\n    /**\r\n     * Set the active color based on a specific point in the color gradient.\r\n     * @param {number} x Left position.\r\n     * @param {number} y Top position.\r\n     */\n    function setColorAtPosition(x, y) {\n      var hsva = {\n        h: hueSlider.value * 1,\n        s: x / colorAreaDims.width * 100,\n        v: 100 - y / colorAreaDims.height * 100,\n        a: alphaSlider.value / 100 };\n\n      var rgba = HSVAtoRGBA(hsva);\n\n      updateMarkerA11yLabel(hsva.s, hsva.v);\n      updateColor(rgba, hsva);\n      pickColor();\n    }\n\n    /**\r\n     * Update the color marker's accessibility label.\r\n     * @param {number} saturation\r\n     * @param {number} value\r\n     */\n    function updateMarkerA11yLabel(saturation, value) {\n      var label = settings.a11y.marker;\n\n      saturation = saturation.toFixed(1) * 1;\n      value = value.toFixed(1) * 1;\n      label = label.replace('{s}', saturation);\n      label = label.replace('{v}', value);\n      colorMarker.setAttribute('aria-label', label);\n    }\n\n    //\n    /**\r\n     * Get the pageX and pageY positions of the pointer.\r\n     * @param {object} event The MouseEvent or TouchEvent object.\r\n     * @return {object} The pageX and pageY positions.\r\n     */\n    function getPointerPosition(event) {\n      return {\n        pageX: event.changedTouches ? event.changedTouches[0].pageX : event.pageX,\n        pageY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY };\n\n    }\n\n    /**\r\n     * Move the color marker when dragged.\r\n     * @param {object} event The MouseEvent object.\r\n     */\n    function moveMarker(event) {\n      var pointer = getPointerPosition(event);\n      var x = pointer.pageX - colorAreaDims.x;\n      var y = pointer.pageY - colorAreaDims.y;\n\n      if (container) {\n        y += container.scrollTop;\n      }\n\n      x = x < 0 ? 0 : x > colorAreaDims.width ? colorAreaDims.width : x;\n      y = y < 0 ? 0 : y > colorAreaDims.height ? colorAreaDims.height : y;\n\n      colorMarker.style.left = x + \"px\";\n      colorMarker.style.top = y + \"px\";\n\n      setColorAtPosition(x, y);\n\n      // Prevent scrolling while dragging the marker\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    /**\r\n     * Move the color marker when the arrow keys are pressed.\r\n     * @param {number} offsetX The horizontal amount to move.\r\n     * * @param {number} offsetY The vertical amount to move.\r\n     */\n    function moveMarkerOnKeydown(offsetX, offsetY) {\n      var x = colorMarker.style.left.replace('px', '') * 1 + offsetX;\n      var y = colorMarker.style.top.replace('px', '') * 1 + offsetY;\n\n      colorMarker.style.left = x + \"px\";\n      colorMarker.style.top = y + \"px\";\n\n      setColorAtPosition(x, y);\n    }\n\n    /**\r\n     * Update the color picker's input field and preview thumb.\r\n     * @param {Object} rgba Red, green, blue and alpha values.\r\n     * @param {Object} [hsva] Hue, saturation, value and alpha values.\r\n     */\n    function updateColor(rgba, hsva) {if (rgba === void 0) {rgba = {};}if (hsva === void 0) {hsva = {};}\n      var format = settings.format;\n\n      for (var key in rgba) {\n        currentColor[key] = rgba[key];\n      }\n\n      for (var _key in hsva) {\n        currentColor[_key] = hsva[_key];\n      }\n\n      var hex = RGBAToHex(currentColor);\n      var opaqueHex = hex.substring(0, 7);\n\n      colorMarker.style.color = opaqueHex;\n      alphaMarker.parentNode.style.color = opaqueHex;\n      alphaMarker.style.color = hex;\n      colorPreview.style.color = hex;\n\n      // Force repaint the color and alpha gradients as a workaround for a Google Chrome bug\n      colorArea.style.display = 'none';\n      colorArea.offsetHeight;\n      colorArea.style.display = '';\n      alphaMarker.nextElementSibling.style.display = 'none';\n      alphaMarker.nextElementSibling.offsetHeight;\n      alphaMarker.nextElementSibling.style.display = '';\n\n      if (format === 'mixed') {\n        format = currentColor.a === 1 ? 'hex' : 'rgb';\n      } else if (format === 'auto') {\n        format = currentFormat;\n      }\n\n      switch (format) {\n        case 'hex':\n          colorValue.value = hex;\n          break;\n        case 'rgb':\n          colorValue.value = RGBAToStr(currentColor);\n          break;\n        case 'hsl':\n          colorValue.value = HSLAToStr(HSVAtoHSLA(currentColor));\n          break;}\n\n\n      // Select the current format in the format switcher\n      document.querySelector(\".clr-format [value=\\\"\" + format + \"\\\"]\").checked = true;\n    }\n\n    /**\r\n     * Set the hue when its slider is moved.\r\n     */\n    function setHue() {\n      var hue = hueSlider.value * 1;\n      var x = colorMarker.style.left.replace('px', '') * 1;\n      var y = colorMarker.style.top.replace('px', '') * 1;\n\n      picker.style.color = \"hsl(\" + hue + \", 100%, 50%)\";\n      hueMarker.style.left = hue / 360 * 100 + \"%\";\n\n      setColorAtPosition(x, y);\n    }\n\n    /**\r\n     * Set the alpha when its slider is moved.\r\n     */\n    function setAlpha() {\n      var alpha = alphaSlider.value / 100;\n\n      alphaMarker.style.left = alpha * 100 + \"%\";\n      updateColor({ a: alpha });\n      pickColor();\n    }\n\n    /**\r\n     * Convert HSVA to RGBA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function HSVAtoRGBA(hsva) {\n      var saturation = hsva.s / 100;\n      var value = hsva.v / 100;\n      var chroma = saturation * value;\n      var hueBy60 = hsva.h / 60;\n      var x = chroma * (1 - Math.abs(hueBy60 % 2 - 1));\n      var m = value - chroma;\n\n      chroma = chroma + m;\n      x = x + m;\n\n      var index = Math.floor(hueBy60) % 6;\n      var red = [chroma, x, m, m, x, chroma][index];\n      var green = [x, chroma, chroma, x, m, m][index];\n      var blue = [m, m, x, chroma, chroma, x][index];\n\n      return {\n        r: Math.round(red * 255),\n        g: Math.round(green * 255),\n        b: Math.round(blue * 255),\n        a: hsva.a };\n\n    }\n\n    /**\r\n     * Convert HSVA to HSLA.\r\n     * @param {object} hsva Hue, saturation, value and alpha values.\r\n     * @return {object} Hue, saturation, lightness and alpha values.\r\n     */\n    function HSVAtoHSLA(hsva) {\n      var value = hsva.v / 100;\n      var lightness = value * (1 - hsva.s / 100 / 2);\n      var saturation;\n\n      if (lightness > 0 && lightness < 1) {\n        saturation = Math.round((value - lightness) / Math.min(lightness, 1 - lightness) * 100);\n      }\n\n      return {\n        h: hsva.h,\n        s: saturation || 0,\n        l: Math.round(lightness * 100),\n        a: hsva.a };\n\n    }\n\n    /**\r\n     * Convert RGBA to HSVA.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {object} Hue, saturation, value and alpha values.\r\n     */\n    function RGBAtoHSVA(rgba) {\n      var red = rgba.r / 255;\n      var green = rgba.g / 255;\n      var blue = rgba.b / 255;\n      var xmax = Math.max(red, green, blue);\n      var xmin = Math.min(red, green, blue);\n      var chroma = xmax - xmin;\n      var value = xmax;\n      var hue = 0;\n      var saturation = 0;\n\n      if (chroma) {\n        if (xmax === red) {hue = (green - blue) / chroma;}\n        if (xmax === green) {hue = 2 + (blue - red) / chroma;}\n        if (xmax === blue) {hue = 4 + (red - green) / chroma;}\n        if (xmax) {saturation = chroma / xmax;}\n      }\n\n      hue = Math.floor(hue * 60);\n\n      return {\n        h: hue < 0 ? hue + 360 : hue,\n        s: Math.round(saturation * 100),\n        v: Math.round(value * 100),\n        a: rgba.a };\n\n    }\n\n    /**\r\n     * Parse a string to RGBA.\r\n     * @param {string} str String representing a color.\r\n     * @return {object} Red, green, blue and alpha values.\r\n     */\n    function strToRGBA(str) {\n      var regex = /^((rgba)|rgb)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]+([\\d.]+)[\\D]*?([\\d.]+|$)/i;\n      var match, rgba;\n\n      // Default to black for invalid color strings\n      ctx.fillStyle = '#000';\n\n      // Use canvas to convert the string to a valid color string\n      ctx.fillStyle = str;\n      match = regex.exec(ctx.fillStyle);\n\n      if (match) {\n        rgba = {\n          r: match[3] * 1,\n          g: match[4] * 1,\n          b: match[5] * 1,\n          a: match[6] * 1 };\n\n\n        // Workaround to mitigate a Chromium bug where the alpha value is rounded incorrectly\n        rgba.a = +rgba.a.toFixed(2);\n\n      } else {\n        match = ctx.fillStyle.replace('#', '').match(/.{2}/g).map(function (h) {return parseInt(h, 16);});\n        rgba = {\n          r: match[0],\n          g: match[1],\n          b: match[2],\n          a: 1 };\n\n      }\n\n      return rgba;\n    }\n\n    /**\r\n     * Convert RGBA to Hex.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} Hex color string.\r\n     */\n    function RGBAToHex(rgba) {\n      var R = rgba.r.toString(16);\n      var G = rgba.g.toString(16);\n      var B = rgba.b.toString(16);\n      var A = '';\n\n      if (rgba.r < 16) {\n        R = '0' + R;\n      }\n\n      if (rgba.g < 16) {\n        G = '0' + G;\n      }\n\n      if (rgba.b < 16) {\n        B = '0' + B;\n      }\n\n      if (settings.alpha && (rgba.a < 1 || settings.forceAlpha)) {\n        var alpha = rgba.a * 255 | 0;\n        A = alpha.toString(16);\n\n        if (alpha < 16) {\n          A = '0' + A;\n        }\n      }\n\n      return '#' + R + G + B + A;\n    }\n\n    /**\r\n     * Convert RGBA values to a CSS rgb/rgba string.\r\n     * @param {object} rgba Red, green, blue and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function RGBAToStr(rgba) {\n      if (!settings.alpha || rgba.a === 1 && !settings.forceAlpha) {\n        return \"rgb(\" + rgba.r + \", \" + rgba.g + \", \" + rgba.b + \")\";\n      } else {\n        return \"rgba(\" + rgba.r + \", \" + rgba.g + \", \" + rgba.b + \", \" + rgba.a + \")\";\n      }\n    }\n\n    /**\r\n     * Convert HSLA values to a CSS hsl/hsla string.\r\n     * @param {object} hsla Hue, saturation, lightness and alpha values.\r\n     * @return {string} CSS color string.\r\n     */\n    function HSLAToStr(hsla) {\n      if (!settings.alpha || hsla.a === 1 && !settings.forceAlpha) {\n        return \"hsl(\" + hsla.h + \", \" + hsla.s + \"%, \" + hsla.l + \"%)\";\n      } else {\n        return \"hsla(\" + hsla.h + \", \" + hsla.s + \"%, \" + hsla.l + \"%, \" + hsla.a + \")\";\n      }\n    }\n\n    /**\r\n     * Init the color picker.\r\n     */\n    function init() {\n      // Render the UI\n      container = null;\n      picker = document.createElement('div');\n      picker.setAttribute('id', 'clr-picker');\n      picker.className = 'clr-picker';\n      picker.innerHTML =\n      \"<input id=\\\"clr-color-value\\\" class=\\\"clr-color\\\" type=\\\"text\\\" value=\\\"\\\" spellcheck=\\\"false\\\" aria-label=\\\"\" + settings.a11y.input + \"\\\">\" + (\"<div id=\\\"clr-color-area\\\" class=\\\"clr-gradient\\\" role=\\\"application\\\" aria-label=\\\"\" +\n      settings.a11y.instruction + \"\\\">\") +\n      '<div id=\"clr-color-marker\" class=\"clr-marker\" tabindex=\"0\"></div>' +\n      '</div>' +\n      '<div class=\"clr-hue\">' + (\"<input id=\\\"clr-hue-slider\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"360\\\" step=\\\"1\\\" aria-label=\\\"\" +\n      settings.a11y.hueSlider + \"\\\">\") +\n      '<div id=\"clr-hue-marker\"></div>' +\n      '</div>' +\n      '<div class=\"clr-alpha\">' + (\"<input id=\\\"clr-alpha-slider\\\" type=\\\"range\\\" min=\\\"0\\\" max=\\\"100\\\" step=\\\"1\\\" aria-label=\\\"\" +\n      settings.a11y.alphaSlider + \"\\\">\") +\n      '<div id=\"clr-alpha-marker\"></div>' +\n      '<span></span>' +\n      '</div>' +\n      '<div id=\"clr-format\" class=\"clr-format\">' +\n      '<fieldset class=\"clr-segmented\">' + (\"<legend>\" +\n      settings.a11y.format + \"</legend>\") +\n      '<input id=\"clr-f1\" type=\"radio\" name=\"clr-format\" value=\"hex\">' +\n      '<label for=\"clr-f1\">Hex</label>' +\n      '<input id=\"clr-f2\" type=\"radio\" name=\"clr-format\" value=\"rgb\">' +\n      '<label for=\"clr-f2\">RGB</label>' +\n      '<input id=\"clr-f3\" type=\"radio\" name=\"clr-format\" value=\"hsl\">' +\n      '<label for=\"clr-f3\">HSL</label>' +\n      '<span></span>' +\n      '</fieldset>' +\n      '</div>' +\n      '<div id=\"clr-swatches\" class=\"clr-swatches\"></div>' + (\"<button type=\\\"button\\\" id=\\\"clr-clear\\\" class=\\\"clr-clear\\\">\" +\n      settings.clearLabel + \"</button>\") + (\"<button type=\\\"button\\\" id=\\\"clr-color-preview\\\" class=\\\"clr-preview\\\" aria-label=\\\"\" +\n      settings.a11y.close + \"\\\"></button>\") + (\"<span id=\\\"clr-open-label\\\" hidden>\" +\n      settings.a11y.open + \"</span>\") + (\"<span id=\\\"clr-swatch-label\\\" hidden>\" +\n      settings.a11y.swatch + \"</span>\");\n\n      // Append the color picker to the DOM\n      document.body.appendChild(picker);\n\n      // Reference the UI elements\n      colorArea = getEl('clr-color-area');\n      colorMarker = getEl('clr-color-marker');\n      clearButton = getEl('clr-clear');\n      colorPreview = getEl('clr-color-preview');\n      colorValue = getEl('clr-color-value');\n      hueSlider = getEl('clr-hue-slider');\n      hueMarker = getEl('clr-hue-marker');\n      alphaSlider = getEl('clr-alpha-slider');\n      alphaMarker = getEl('clr-alpha-marker');\n\n      // Bind the picker to the default selector\n      bindFields(settings.el);\n      wrapFields(settings.el);\n\n      addListener(picker, 'mousedown', function (event) {\n        picker.classList.remove('clr-keyboard-nav');\n        event.stopPropagation();\n      });\n\n      addListener(colorArea, 'mousedown', function (event) {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorArea, 'touchstart', function (event) {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorMarker, 'mousedown', function (event) {\n        addListener(document, 'mousemove', moveMarker);\n      });\n\n      addListener(colorMarker, 'touchstart', function (event) {\n        document.addEventListener('touchmove', moveMarker, { passive: false });\n      });\n\n      addListener(colorValue, 'change', function (event) {\n        setColorFromStr(colorValue.value);\n        pickColor();\n      });\n\n      addListener(clearButton, 'click', function (event) {\n        pickColor('');\n        closePicker();\n      });\n\n      addListener(colorPreview, 'click', function (event) {\n        pickColor();\n        closePicker();\n      });\n\n      addListener(document, 'click', '.clr-format input', function (event) {\n        currentFormat = event.target.value;\n        updateColor();\n        pickColor();\n      });\n\n      addListener(picker, 'click', '.clr-swatches button', function (event) {\n        setColorFromStr(event.target.textContent);\n        pickColor();\n\n        if (settings.swatchesOnly) {\n          closePicker();\n        }\n      });\n\n      addListener(document, 'mouseup', function (event) {\n        document.removeEventListener('mousemove', moveMarker);\n      });\n\n      addListener(document, 'touchend', function (event) {\n        document.removeEventListener('touchmove', moveMarker);\n      });\n\n      addListener(document, 'mousedown', function (event) {\n        picker.classList.remove('clr-keyboard-nav');\n        closePicker();\n      });\n\n      addListener(document, 'keydown', function (event) {\n        if (event.key === 'Escape') {\n          closePicker(true);\n        } else if (event.key === 'Tab') {\n          picker.classList.add('clr-keyboard-nav');\n        }\n      });\n\n      addListener(document, 'click', '.clr-field button', function (event) {\n        // Reset any previously set per-instance options\n        if (hasInstance) {\n          resetVirtualInstance();\n        }\n\n        // Open the color picker\n        event.target.nextElementSibling.dispatchEvent(new Event('click', { bubbles: true }));\n      });\n\n      addListener(colorMarker, 'keydown', function (event) {\n        var movements = {\n          ArrowUp: [0, -1],\n          ArrowDown: [0, 1],\n          ArrowLeft: [-1, 0],\n          ArrowRight: [1, 0] };\n\n\n        if (Object.keys(movements).indexOf(event.key) !== -1) {\n          moveMarkerOnKeydown.apply(void 0, movements[event.key]);\n          event.preventDefault();\n        }\n      });\n\n      addListener(colorArea, 'click', moveMarker);\n      addListener(hueSlider, 'input', setHue);\n      addListener(alphaSlider, 'input', setAlpha);\n    }\n\n    /**\r\n     * Shortcut for getElementById to optimize the minified JS.\r\n     * @param {string} id The element id.\r\n     * @return {object} The DOM element with the provided id.\r\n     */\n    function getEl(id) {\n      return document.getElementById(id);\n    }\n\n    /**\r\n     * Shortcut for addEventListener to optimize the minified JS.\r\n     * @param {object} context The context to which the listener is attached.\r\n     * @param {string} type Event type.\r\n     * @param {(string|function)} selector Event target if delegation is used, event handler if not.\r\n     * @param {function} [fn] Event handler if delegation is used.\r\n     */\n    function addListener(context, type, selector, fn) {\n      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n\n      // Delegate event to the target of the selector\n      if (typeof selector === 'string') {\n        context.addEventListener(type, function (event) {\n          if (matches.call(event.target, selector)) {\n            fn.call(event.target, event);\n          }\n        });\n\n        // If the selector is not a string then it's a function\n        // in which case we need regular event listener\n      } else {\n        fn = selector;\n        context.addEventListener(type, fn);\n      }\n    }\n\n    /**\r\n     * Call a function only when the DOM is ready.\r\n     * @param {function} fn The function to call.\r\n     * @param {array} [args] Arguments to pass to the function.\r\n     */\n    function DOMReady(fn, args) {\n      args = args !== undefined ? args : [];\n\n      if (document.readyState !== 'loading') {\n        fn.apply(void 0, args);\n      } else {\n        document.addEventListener('DOMContentLoaded', function () {\n          fn.apply(void 0, args);\n        });\n      }\n    }\n\n    // Polyfill for Nodelist.forEach\n    if (NodeList !== undefined && NodeList.prototype && !NodeList.prototype.forEach) {\n      NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n\n    // Expose the color picker to the global scope\n    var Coloris = function () {\n      var methods = {\n        init: init,\n        set: configure,\n        wrap: wrapFields,\n        close: closePicker,\n        setInstance: setVirtualInstance,\n        removeInstance: removeVirtualInstance,\n        updatePosition: updatePickerPosition };\n\n\n      function Coloris(options) {\n        DOMReady(function () {\n          if (options) {\n            if (typeof options === 'string') {\n              bindFields(options);\n            } else {\n              configure(options);\n            }\n          }\n        });\n      }var _loop2 = function _loop2(\n\n      key) {\n        Coloris[key] = function () {for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {args[_key2] = arguments[_key2];}\n          DOMReady(methods[key], args);\n        };};for (var key in methods) {_loop2(key);\n      }\n\n      return Coloris;\n    }();\n\n    // Ensure init function is available not only as as a default import\n    Coloris.coloris = Coloris;\n\n    // Init the color picker when the DOM is ready\n    return Coloris;\n\n  }(window, document, Math);\n\n});\n\n//# sourceURL=webpack://svgEditor/./node_modules/@melloware/coloris/dist/umd/coloris.js?");

/***/ }),

/***/ "./node_modules/bezier-js/dist/bezier.cjs":
/*!************************************************!*\
  !*** ./node_modules/bezier-js/dist/bezier.cjs ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Bezier = void 0;\n// math-inlining.\nconst {\n  abs,\n  cos,\n  sin,\n  acos,\n  atan2,\n  sqrt,\n  pow\n} = Math; // cube root function yielding real roots\n\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n} // trig constants\n\n\nconst pi = Math.PI,\n      tau = 2 * pi,\n      quart = pi / 2,\n      // float precision significant decimal\nepsilon = 0.000001,\n      // extremas used in bbox calculation and similar algorithms\nnMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n      nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n      // a zero coordinate, which is surprisingly useful\nZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n}; // Bezier utility functions\n\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n\n    return sqrt(l);\n  },\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points; // constant?\n\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n\n      return ret;\n    } // quadratic/cubic curve?\n\n\n    if (order < 4) {\n      let mt2 = mt * mt,\n          t2 = t * t,\n          a,\n          b,\n          c,\n          d = 0;\n\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n\n      return ret;\n    } // higher order curves: use de Casteljau's computation\n\n\n    const dCpts = JSON.parse(JSON.stringify(points));\n\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n          r = ratios,\n          p = points;\n    let f1 = r[0],\n        f2 = r[1],\n        f3 = r[2],\n        f4 = r[3],\n        d; // spec for linear\n\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t\n      };\n    } // upgrade to quadratic\n\n\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t\n      };\n    } // upgrade to cubic\n\n\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t\n      };\n    }\n  },\n  derive: function (points, _3d) {\n    const dpoints = [];\n\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n\n        list.push(dpt);\n      }\n\n      dpoints.push(list);\n      p = list;\n    }\n\n    return dpoints;\n  },\n  between: function (v, m, M) {\n    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);\n  },\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n  length: function (derivativeFn) {\n    const z = 0.5,\n          len = utils.Tvalues.length;\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n\n    return z * sum;\n  },\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n          d2 = te - ts,\n          v2 = v - ds,\n          r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n\n    return ret;\n  },\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n\n    return s;\n  },\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n          dy1 = v1.y - o.y,\n          dx2 = v2.x - o.x,\n          dy2 = v2.y - o.y,\n          cross = dx1 * dy2 - dy1 * dx2,\n          dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n        mpos,\n        d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return {\n      mdist: mdist,\n      mpos: mpos\n    };\n  },\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const bottom = pow(t, n) + pow(1 - t, n),\n          top = bottom - 1;\n    return abs(top / bottom);\n  },\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const top = pow(1 - t, n),\n          bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n          ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n          d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n    if (d == 0) {\n      return false;\n    }\n\n    return {\n      x: nx / d,\n      y: ny / d\n    };\n  },\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          x3 = p3.x,\n          y3 = p3.y,\n          x4 = p4.x,\n          y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function (p1, p2) {\n    return new Bezier(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, p2.x, p2.y);\n  },\n  findbbox: function (sections) {\n    let mx = nMax,\n        my = nMax,\n        MX = nMin,\n        MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: {\n        min: mx,\n        mid: (mx + MX) / 2,\n        max: MX,\n        size: MX - mx\n      },\n      y: {\n        min: my,\n        mid: (my + MY) / 2,\n        max: MY,\n        size: MY - my\n      }\n    };\n  },\n  shapeintersections: function (s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n\n    return shape;\n  },\n  getminmax: function (curve, d, list) {\n    if (!list) return {\n      min: 0,\n      max: 0\n    };\n    let min = nMax,\n        max = nMin,\n        t,\n        c;\n\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n\n      if (c[d] < min) {\n        min = c[d];\n      }\n\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n\n    return {\n      min: min,\n      mid: (min + max) / 2,\n      max: max,\n      size: max - min\n    };\n  },\n  align: function (points, line) {\n    const tx = line.p1.x,\n          ty = line.p1.y,\n          a = -atan2(line.p2.y - ty, line.p2.x - tx),\n          d = function (v) {\n      return {\n        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n      };\n    };\n\n    return points.map(d);\n  },\n  roots: function (points, line) {\n    line = line || {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 1,\n        y: 0\n      }\n    };\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n            b = aligned[1].y,\n            c = aligned[2].y,\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n\n      return [];\n    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n\n\n    const pa = aligned[0].y,\n          pb = aligned[1].y,\n          pc = aligned[2].y,\n          pd = aligned[3].y;\n    let d = -pa + 3 * pb - 3 * pc + pd,\n        a = 3 * pa - 6 * pb + 3 * pc,\n        b = -3 * pa + 3 * pb,\n        c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        } // linear solution:\n\n\n        return [-c / b].filter(reduce);\n      } // quadratic solution:\n\n\n      const q = sqrt(b * b - 4 * a * c),\n            a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    } // at this point, we know we need a cubic solution:\n\n\n    a /= d;\n    b /= d;\n    c /= d;\n    const p = (3 * b - a * a) / 3,\n          p3 = p / 3,\n          q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n          q2 = q / 2,\n          discriminant = q2 * q2 + p3 * p3 * p3;\n    let u1, v1, x1, x2, x3;\n\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n            mp33 = mp3 * mp3 * mp3,\n            r = sqrt(mp33),\n            t = -q / (2 * r),\n            cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n            phi = acos(cosphi),\n            crtr = crt(r),\n            t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n            b = p[1],\n            c = p[2],\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n\n      return [];\n    } // linear roots are even easier\n\n\n    if (p.length === 2) {\n      const a = p[0],\n            b = p[1];\n\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n\n      return [];\n    }\n\n    return [];\n  },\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n        dnm,\n        adk,\n        dk,\n        k = 0,\n        r = 0; //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return {\n        k: 0,\n        r: 0\n      };\n    }\n\n    k = num / dnm;\n    r = dnm / num; // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return {\n      k: k,\n      r: r,\n      dk: dk,\n      adk: adk\n    };\n  },\n  inflections: function (points) {\n    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, {\n      p1: points[0],\n      p2: points.slice(-1)[0]\n    }),\n          a = p[2].x * p[1].y,\n          b = p[3].x * p[1].y,\n          c = p[1].x * p[2].y,\n          d = p[3].x * p[2].y,\n          v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n          v2 = 18 * (3 * a - b - 3 * c),\n          v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n          sq = Math.sqrt(trm),\n          d2 = 2 * v1;\n    if (utils.approximately(d2, 0)) return [];\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n          len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n\n    return true;\n  },\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n          c2b = c2.bbox(),\n          r = 100000,\n          threshold = curveIntersectionThreshold || 0.5;\n\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];\n    }\n\n    let cc1 = c1.split(0.5),\n        cc2 = c2.split(0.5),\n        pairs = [{\n      left: cc1.left,\n      right: cc2.left\n    }, {\n      left: cc1.left,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.left\n    }];\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    let results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n          dy1 = p2.y - p1.y,\n          dx2 = p3.x - p2.x,\n          dy2 = p3.y - p2.y,\n          dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n          dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n          dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n          dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n          // chord midpoints\n    mx1 = (p1.x + p2.x) / 2,\n          my1 = (p1.y + p2.y) / 2,\n          mx2 = (p2.x + p3.x) / 2,\n          my2 = (p2.y + p3.y) / 2,\n          // midpoint offsets\n    mx1n = mx1 + dx1p,\n          my1n = my1 + dy1p,\n          mx2n = mx2 + dx2p,\n          my2n = my2 + dy2p,\n          // intersection of these lines:\n    arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n          r = utils.dist(arc, p1); // arc start/end values, over mid point:\n\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n        m = atan2(p2.y - arc.y, p2.x - arc.x),\n        e = atan2(p3.y - arc.y, p3.x - arc.x),\n        _; // determine arc direction (cw/ccw correction)\n\n\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    } // assign and done.\n\n\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function (a, b) {\n    return a - b;\n  }\n};\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\n\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return \"[\" + this.curves.map(function (curve) {\n      return utils.pointsToString(curve.points);\n    }).join(\", \") + \"]\";\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves.map(function (v) {\n      return v.length();\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n\n}\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n// math-inlining.\n\n\nconst {\n  abs: abs$1,\n  min,\n  max,\n  cos: cos$1,\n  sin: sin$1,\n  acos: acos$1,\n  sqrt: sqrt$1\n} = Math;\nconst pi$1 = Math.PI;\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nclass Bezier {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    const points = this.points = [];\n\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length; // is this curve, practically speaking, a straight line?\n\n    const aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs$1(p.y), 0) < baselength / 50;\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } // shortcuts, although they're really dumb\n\n\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    } // real fitting.\n\n\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    const abc = Bezier.getABC(3, S, B, E, t);\n\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n\n    const d2 = d1 * (1 - t) / t;\n    const selen = utils.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n    const e1 = {\n      x: B.x - bx1,\n      y: B.y - by1\n    },\n          e2 = {\n      x: B.x + bx2,\n      y: B.y + by2\n    },\n          A = abc.A,\n          v1 = {\n      x: A.x + (e1.x - A.x) / (1 - t),\n      y: A.y + (e1.y - A.y) / (1 - t)\n    },\n          v2 = {\n      x: A.x + (e2.x - A.x) / t,\n      y: A.y + (e2.y - A.y) / t\n    },\n          nc1 = {\n      x: S.x + (v1.x - S.x) / t,\n      y: S.y + (v1.y - S.y) / t\n    },\n          nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    }; // ...done\n\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points.map(function (c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    },\n          s = utils.abcratio(t, order),\n          A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return {\n      A,\n      B,\n      C,\n      S,\n      E\n    };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n\n    this._lut = []; // n steps means n+1 points\n\n    steps++;\n    this._lut = [];\n\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n\n      this._lut.push(p);\n    }\n\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n          hits = [];\n\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n\n    if (!hits.length) return false;\n    return t /= hits.length;\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n    let mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n    mdist += 1;\n\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, {\n      p1: p[0],\n      p2: p[p.length - 1]\n    }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt$1(d.x * d.x + d.y * d.y);\n    return {\n      x: -d.y / q,\n      y: d.x / q\n    };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2; // cross product\n\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m; // rotation matrix\n\n    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n    while (p.length > 1) {\n      _p = [];\n\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n\n        _p.push(pt);\n      }\n\n      p = _p;\n    }\n\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n\n    if (t2 === 1) {\n      return this.split(t1).right;\n    } // no shortcut: use \"de Casteljau\" iteration.\n\n\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    }; // make sure we bind _t1/_t2 information!\n\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n    if (!t2) {\n      return result;\n    } // if we have a t2, split again:\n\n\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function (dim) {\n      let mfn = function (v) {\n        return v[dim];\n      };\n\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n\n      result[dim] = result[dim].filter(function (t) {\n        return t >= 0 && t <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n          result = {};\n    this.dims.forEach(function (d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n          tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n            n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n\n      return ret;\n    }\n\n    if (this._linear) {\n      const nv = this.normal(0),\n            coords = this.points.map(function (p) {\n        const ret = {\n          x: p.x + t * nv.x,\n          y: p.y + t * nv.y\n        };\n\n        if (p.z && nv.z) {\n          ret.z = p.z + t * nv.z;\n        }\n\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n    }\n\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n\n    return abs$1(acos$1(s)) < pi$1 / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = []; // first pass: split on extrema\n\n    let extrema = this.extrema().values;\n\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    } // second pass: further reduce these segments to simple segments\n\n\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n\n          if (!segment.simple()) {\n            t2 -= step;\n\n            if (abs$1(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1; // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + i / o * d2);\n    return new Bezier(this.points.map((p, i) => ({\n      x: p.x + v.x * d[i],\n      y: p.y + v.y * d[i]\n    })));\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    } // TODO: add special handling for non-linear degenerate curves.\n\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d, distanceFn ? distanceFn(1) : d);\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    } // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n\n\n    [0, 1].forEach(function (t) {\n      const p = np[t * order] = utils.copy(points[t * order]);\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(t => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = {\n          x: p.x + d.x,\n          y: p.y + d.y\n        };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    } // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n\n\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = {\n        x: start.x + n.x * d1,\n        y: start.y + n.y * d1\n      };\n      e = {\n        x: end.x + n.x * d3,\n        y: end.y + n.y * d3\n      };\n      mid = {\n        x: (s.x + e.x) / 2,\n        y: (s.y + e.y) / 2\n      };\n      const fline = [s, mid, e];\n      s = {\n        x: start.x - n.x * d2,\n        y: start.y - n.y * d2\n      };\n      e = {\n        x: end.x - n.x * d4,\n        y: end.y - n.y * d4\n      };\n      mid = {\n        x: (s.x + e.x) / 2,\n        y: (s.y + e.y) / 2\n      };\n      const bline = [e, mid, s];\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n    let bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    } // form curve oulines\n\n\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n\n      alen += slen;\n    }); // reverse the \"return\" outline\n\n    bcurves = bcurves.map(function (s) {\n      p = s.points;\n\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n\n      return s;\n    }).reverse(); // form the endcaps as lines\n\n    const fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter(t => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n    const reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = []; // step 1: pair off any overlapping segments\n\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({\n            left: l,\n            right: r\n          });\n        }\n      });\n    }); // step 2: for each pairing, run through the convergence algorithm.\n\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n    return abs$1(d1 - ref) + abs$1(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n        t_e = 1,\n        safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n    do {\n      safety = 0; // step 1: start with the maximum possible arc\n\n      t_e = 1; // points:\n\n      let np1 = this.get(t_s),\n          np2,\n          np3,\n          arc,\n          prev_arc; // booleans:\n\n      let curr_good = false,\n          prev_good = false,\n          done; // numbers:\n\n      let t_m = t_e,\n          prev_e = 1; // step 2: find the best possible arc\n\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos$1(arc.e),\n                y: arc.y + arc.r * sin$1(arc.e)\n              };\n              arc.e += utils.angle({\n                x: arc.x,\n                y: arc.y\n              }, d, this.get(1));\n            }\n\n            break;\n          } // if not, move it up by half the iteration distance\n\n\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n\n    return circles;\n  }\n\n}\n\nexports.Bezier = Bezier;\n\n\n//# sourceURL=webpack://svgEditor/./node_modules/bezier-js/dist/bezier.cjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./components/NoteEditor/ImageEditor/editor.ts");
/******/ 	window.svgEditor = __webpack_exports__;
/******/ 	
/******/ })()
;